// Code generated by protoc-gen-go. DO NOT EDIT.
// source: v1alpha1/proto/grafeas.proto

/*
Package grafeas is a generated protocol buffer package.

It is generated from these files:
	v1alpha1/proto/grafeas.proto

It has these top-level messages:
	GetOccurrenceRequest
	ListOccurrencesRequest
	DeleteOccurrenceRequest
	CreateOccurrenceRequest
	UpdateOccurrenceRequest
	GetNoteRequest
	GetOccurrenceNoteRequest
	ListNotesRequest
	DeleteNoteRequest
	CreateNoteRequest
	UpdateNoteRequest
	ListNoteOccurrencesRequest
	ListNoteOccurrencesResponse
	ListNotesResponse
	ListOccurrencesResponse
	ListOperationsResponse
	UpdateOperationRequest
	CreateOperationRequest
	OperationMetadata
	Artifact
	AttestationAuthority
	BuildDetails
	BuildProvenance
	BuildSignature
	BuildType
	Command
	Deployable
	DockerImage
	Discovery
	FileHashes
	Hash
	Note
	Occurrence
	PackageManager
	PgpSignedAttestation
	Source
	RepoSource
	StorageSource
	VulnerabilityType
*/
package grafeas

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/golang/protobuf/ptypes/empty"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf2 "github.com/golang/protobuf/ptypes/timestamp"
import google_longrunning "google.golang.org/genproto/googleapis/longrunning"
import google_devtools_source_v1 "google.golang.org/genproto/googleapis/devtools/source/v1"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The type of the key, either stored in `public_key` or referenced in
// `key_id`
type BuildSignature_KeyType int32

const (
	BuildSignature_UNSET             BuildSignature_KeyType = 0
	BuildSignature_PGP_ASCII_ARMORED BuildSignature_KeyType = 1
	BuildSignature_PKIX_PEM          BuildSignature_KeyType = 2
)

var BuildSignature_KeyType_name = map[int32]string{
	0: "UNSET",
	1: "PGP_ASCII_ARMORED",
	2: "PKIX_PEM",
}
var BuildSignature_KeyType_value = map[string]int32{
	"UNSET":             0,
	"PGP_ASCII_ARMORED": 1,
	"PKIX_PEM":          2,
}

func (x BuildSignature_KeyType) String() string {
	return proto.EnumName(BuildSignature_KeyType_name, int32(x))
}
func (BuildSignature_KeyType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{23, 0} }

// The recovered Dockerfile directive used to construct this layer.
type DockerImage_Layer_Directive int32

const (
	DockerImage_Layer_UNKNOWN_DIRECTIVE DockerImage_Layer_Directive = 0
	DockerImage_Layer_MAINTAINER        DockerImage_Layer_Directive = 1
	DockerImage_Layer_RUN               DockerImage_Layer_Directive = 2
	DockerImage_Layer_CMD               DockerImage_Layer_Directive = 3
	DockerImage_Layer_LABEL             DockerImage_Layer_Directive = 4
	DockerImage_Layer_EXPOSE            DockerImage_Layer_Directive = 5
	DockerImage_Layer_ENV               DockerImage_Layer_Directive = 6
	DockerImage_Layer_ADD               DockerImage_Layer_Directive = 7
	DockerImage_Layer_COPY              DockerImage_Layer_Directive = 8
	DockerImage_Layer_ENTRYPOINT        DockerImage_Layer_Directive = 9
	DockerImage_Layer_VOLUME            DockerImage_Layer_Directive = 10
	DockerImage_Layer_USER              DockerImage_Layer_Directive = 11
	DockerImage_Layer_WORKDIR           DockerImage_Layer_Directive = 12
	DockerImage_Layer_ARG               DockerImage_Layer_Directive = 13
	DockerImage_Layer_ONBUILD           DockerImage_Layer_Directive = 14
	DockerImage_Layer_STOPSIGNAL        DockerImage_Layer_Directive = 15
	DockerImage_Layer_HEALTHCHECK       DockerImage_Layer_Directive = 16
	DockerImage_Layer_SHELL             DockerImage_Layer_Directive = 17
)

var DockerImage_Layer_Directive_name = map[int32]string{
	0:  "UNKNOWN_DIRECTIVE",
	1:  "MAINTAINER",
	2:  "RUN",
	3:  "CMD",
	4:  "LABEL",
	5:  "EXPOSE",
	6:  "ENV",
	7:  "ADD",
	8:  "COPY",
	9:  "ENTRYPOINT",
	10: "VOLUME",
	11: "USER",
	12: "WORKDIR",
	13: "ARG",
	14: "ONBUILD",
	15: "STOPSIGNAL",
	16: "HEALTHCHECK",
	17: "SHELL",
}
var DockerImage_Layer_Directive_value = map[string]int32{
	"UNKNOWN_DIRECTIVE": 0,
	"MAINTAINER":        1,
	"RUN":               2,
	"CMD":               3,
	"LABEL":             4,
	"EXPOSE":            5,
	"ENV":               6,
	"ADD":               7,
	"COPY":              8,
	"ENTRYPOINT":        9,
	"VOLUME":            10,
	"USER":              11,
	"WORKDIR":           12,
	"ARG":               13,
	"ONBUILD":           14,
	"STOPSIGNAL":        15,
	"HEALTHCHECK":       16,
	"SHELL":             17,
}

func (x DockerImage_Layer_Directive) String() string {
	return proto.EnumName(DockerImage_Layer_Directive_name, int32(x))
}
func (DockerImage_Layer_Directive) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{27, 0, 0}
}

// The type of hash that was performed.
type Hash_Type int32

const (
	Hash_NONE   Hash_Type = 0
	Hash_SHA256 Hash_Type = 1
	Hash_MD5    Hash_Type = 2
)

var Hash_Type_name = map[int32]string{
	0: "NONE",
	1: "SHA256",
	2: "MD5",
}
var Hash_Type_value = map[string]int32{
	"NONE":   0,
	"SHA256": 1,
	"MD5":    2,
}

func (x Hash_Type) String() string {
	return proto.EnumName(Hash_Type_name, int32(x))
}
func (Hash_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{30, 0} }

// This must be 1:1 with members of our oneofs, it can be used for filtering
// Note and Occurrence on their kind.
type Note_Kind int32

const (
	// Unknown
	Note_KIND_UNSPECIFIED Note_Kind = 0
	// The note and occurrence represent a package vulnerability.
	Note_PACKAGE_VULNERABILITY Note_Kind = 1
	// The note and occurrence assert build provenance.
	Note_BUILD_DETAILS Note_Kind = 2
	// This represents an image basis relationship.
	Note_IMAGE_BASIS Note_Kind = 3
	// This represents a package installed via a package manager.
	Note_PACKAGE_MANAGER Note_Kind = 4
	// The note and occurrence track deployment events.
	Note_DEPLOYABLE Note_Kind = 5
	// The note and occurrence track the initial discovery status of a resource.
	Note_DISCOVERY Note_Kind = 6
	// This represents a logical "role" that can attest to artifacts.
	Note_ATTESTATION_AUTHORITY Note_Kind = 7
)

var Note_Kind_name = map[int32]string{
	0: "KIND_UNSPECIFIED",
	1: "PACKAGE_VULNERABILITY",
	2: "BUILD_DETAILS",
	3: "IMAGE_BASIS",
	4: "PACKAGE_MANAGER",
	5: "DEPLOYABLE",
	6: "DISCOVERY",
	7: "ATTESTATION_AUTHORITY",
}
var Note_Kind_value = map[string]int32{
	"KIND_UNSPECIFIED":      0,
	"PACKAGE_VULNERABILITY": 1,
	"BUILD_DETAILS":         2,
	"IMAGE_BASIS":           3,
	"PACKAGE_MANAGER":       4,
	"DEPLOYABLE":            5,
	"DISCOVERY":             6,
	"ATTESTATION_AUTHORITY": 7,
}

func (x Note_Kind) String() string {
	return proto.EnumName(Note_Kind_name, int32(x))
}
func (Note_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{31, 0} }

// The CPU architecture for which packages in this distribution
// channel were built
type PackageManager_Distribution_Architecture int32

const (
	PackageManager_Distribution_UNKNOWN PackageManager_Distribution_Architecture = 0
	PackageManager_Distribution_X86     PackageManager_Distribution_Architecture = 1
	PackageManager_Distribution_X64     PackageManager_Distribution_Architecture = 2
)

var PackageManager_Distribution_Architecture_name = map[int32]string{
	0: "UNKNOWN",
	1: "X86",
	2: "X64",
}
var PackageManager_Distribution_Architecture_value = map[string]int32{
	"UNKNOWN": 0,
	"X86":     1,
	"X64":     2,
}

func (x PackageManager_Distribution_Architecture) String() string {
	return proto.EnumName(PackageManager_Distribution_Architecture_name, int32(x))
}
func (PackageManager_Distribution_Architecture) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{33, 1, 0}
}

// Whether this is an ordinary package version or a
// sentinel MIN/MAX version.
type PackageManager_Version_VersionKind int32

const (
	// A standard package version, defined by the other fields.
	PackageManager_Version_NORMAL PackageManager_Version_VersionKind = 0
	// A special version representing negative infinity,
	// other fields are ignored.
	PackageManager_Version_MINIMUM PackageManager_Version_VersionKind = 1
	// A special version representing positive infinity,
	// other fields are ignored.
	PackageManager_Version_MAXIMUM PackageManager_Version_VersionKind = 2
)

var PackageManager_Version_VersionKind_name = map[int32]string{
	0: "NORMAL",
	1: "MINIMUM",
	2: "MAXIMUM",
}
var PackageManager_Version_VersionKind_value = map[string]int32{
	"NORMAL":  0,
	"MINIMUM": 1,
	"MAXIMUM": 2,
}

func (x PackageManager_Version_VersionKind) String() string {
	return proto.EnumName(PackageManager_Version_VersionKind_name, int32(x))
}
func (PackageManager_Version_VersionKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{33, 2, 0}
}

// Type (e.g. schema) of the attestation payload that was signed.
type PgpSignedAttestation_ContentType int32

const (
	// ContentType is not set.
	PgpSignedAttestation_CONTENT_TYPE_UNSPECIFIED PgpSignedAttestation_ContentType = 0
	// Atomic format attestation signature. See
	// https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md
	// The payload extracted from `signature` is a JSON blob conforming to the
	// linked schema.
	PgpSignedAttestation_SIMPLE_SIGNING_JSON PgpSignedAttestation_ContentType = 1
)

var PgpSignedAttestation_ContentType_name = map[int32]string{
	0: "CONTENT_TYPE_UNSPECIFIED",
	1: "SIMPLE_SIGNING_JSON",
}
var PgpSignedAttestation_ContentType_value = map[string]int32{
	"CONTENT_TYPE_UNSPECIFIED": 0,
	"SIMPLE_SIGNING_JSON":      1,
}

func (x PgpSignedAttestation_ContentType) String() string {
	return proto.EnumName(PgpSignedAttestation_ContentType_name, int32(x))
}
func (PgpSignedAttestation_ContentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{34, 0}
}

// Note provider-assigned severity/impact ranking
type VulnerabilityType_Severity int32

const (
	VulnerabilityType_SEVERITY_UNSPECIFIED VulnerabilityType_Severity = 0
	VulnerabilityType_MINIMAL              VulnerabilityType_Severity = 1
	VulnerabilityType_LOW                  VulnerabilityType_Severity = 2
	VulnerabilityType_MEDIUM               VulnerabilityType_Severity = 3
	VulnerabilityType_HIGH                 VulnerabilityType_Severity = 4
	VulnerabilityType_CRITICAL             VulnerabilityType_Severity = 5
)

var VulnerabilityType_Severity_name = map[int32]string{
	0: "SEVERITY_UNSPECIFIED",
	1: "MINIMAL",
	2: "LOW",
	3: "MEDIUM",
	4: "HIGH",
	5: "CRITICAL",
}
var VulnerabilityType_Severity_value = map[string]int32{
	"SEVERITY_UNSPECIFIED": 0,
	"MINIMAL":              1,
	"LOW":                  2,
	"MEDIUM":               3,
	"HIGH":                 4,
	"CRITICAL":             5,
}

func (x VulnerabilityType_Severity) String() string {
	return proto.EnumName(VulnerabilityType_Severity_name, int32(x))
}
func (VulnerabilityType_Severity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{38, 0}
}

// Whether this is an ordinary package version or a
// sentinel MIN/MAX version.
type VulnerabilityType_Version_VersionKind int32

const (
	// A standard package version, defined by the other fields.
	VulnerabilityType_Version_NORMAL VulnerabilityType_Version_VersionKind = 0
	// A special version representing negative infinity,
	// other fields are ignored.
	VulnerabilityType_Version_MINIMUM VulnerabilityType_Version_VersionKind = 1
	// A special version representing positive infinity,
	// other fields are ignored.
	VulnerabilityType_Version_MAXIMUM VulnerabilityType_Version_VersionKind = 2
)

var VulnerabilityType_Version_VersionKind_name = map[int32]string{
	0: "NORMAL",
	1: "MINIMUM",
	2: "MAXIMUM",
}
var VulnerabilityType_Version_VersionKind_value = map[string]int32{
	"NORMAL":  0,
	"MINIMUM": 1,
	"MAXIMUM": 2,
}

func (x VulnerabilityType_Version_VersionKind) String() string {
	return proto.EnumName(VulnerabilityType_Version_VersionKind_name, int32(x))
}
func (VulnerabilityType_Version_VersionKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{38, 0, 0}
}

// Request to get a Occurrence.
type GetOccurrenceRequest struct {
	// The name of the occurrence in the form
	// "projects/{project_id}/occurrences/{occurrence_id}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *GetOccurrenceRequest) Reset()                    { *m = GetOccurrenceRequest{} }
func (m *GetOccurrenceRequest) String() string            { return proto.CompactTextString(m) }
func (*GetOccurrenceRequest) ProtoMessage()               {}
func (*GetOccurrenceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *GetOccurrenceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to list occurrences.
type ListOccurrencesRequest struct {
	// This contains the projectId for example: projects/{project_id}
	Parent string `protobuf:"bytes,5,opt,name=parent" json:"parent,omitempty"`
	// The filter expression.
	Filter string `protobuf:"bytes,2,opt,name=filter" json:"filter,omitempty"`
	// Number of occurrences to return in the list.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
	// Token to provide to skip to a particular spot in the list.
	PageToken string `protobuf:"bytes,4,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
}

func (m *ListOccurrencesRequest) Reset()                    { *m = ListOccurrencesRequest{} }
func (m *ListOccurrencesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListOccurrencesRequest) ProtoMessage()               {}
func (*ListOccurrencesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ListOccurrencesRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *ListOccurrencesRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *ListOccurrencesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListOccurrencesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// Request to delete a occurrence
type DeleteOccurrenceRequest struct {
	// The name of the occurrence in the form
	// "projects/{project_id}/occurrences/{occurrence_id}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DeleteOccurrenceRequest) Reset()                    { *m = DeleteOccurrenceRequest{} }
func (m *DeleteOccurrenceRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteOccurrenceRequest) ProtoMessage()               {}
func (*DeleteOccurrenceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DeleteOccurrenceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to insert a new occurrence
type CreateOccurrenceRequest struct {
	// This field contains the projectId for example: "projects/{project_id}"
	Parent string `protobuf:"bytes,3,opt,name=parent" json:"parent,omitempty"`
	// The occurrence to be inserted
	Occurrence *Occurrence `protobuf:"bytes,2,opt,name=occurrence" json:"occurrence,omitempty"`
}

func (m *CreateOccurrenceRequest) Reset()                    { *m = CreateOccurrenceRequest{} }
func (m *CreateOccurrenceRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateOccurrenceRequest) ProtoMessage()               {}
func (*CreateOccurrenceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CreateOccurrenceRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *CreateOccurrenceRequest) GetOccurrence() *Occurrence {
	if m != nil {
		return m.Occurrence
	}
	return nil
}

// Request to update an existing occurrence
type UpdateOccurrenceRequest struct {
	// The name of the occurrence.
	// Should be of the form "projects/{project_id}/occurrences/{occurrence_id}".
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The updated occurrence.
	Occurrence *Occurrence `protobuf:"bytes,2,opt,name=occurrence" json:"occurrence,omitempty"`
}

func (m *UpdateOccurrenceRequest) Reset()                    { *m = UpdateOccurrenceRequest{} }
func (m *UpdateOccurrenceRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateOccurrenceRequest) ProtoMessage()               {}
func (*UpdateOccurrenceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *UpdateOccurrenceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateOccurrenceRequest) GetOccurrence() *Occurrence {
	if m != nil {
		return m.Occurrence
	}
	return nil
}

// Request to get a Note.
type GetNoteRequest struct {
	// The name of the note in the form
	// "providers/{provider_id}/notes/{note_id}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *GetNoteRequest) Reset()                    { *m = GetNoteRequest{} }
func (m *GetNoteRequest) String() string            { return proto.CompactTextString(m) }
func (*GetNoteRequest) ProtoMessage()               {}
func (*GetNoteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetNoteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to get the note to which this occurrence is attached.
type GetOccurrenceNoteRequest struct {
	// The name of the occurrence in the form
	// "projects/{project_id}/occurrences/{occurrence_id}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *GetOccurrenceNoteRequest) Reset()                    { *m = GetOccurrenceNoteRequest{} }
func (m *GetOccurrenceNoteRequest) String() string            { return proto.CompactTextString(m) }
func (*GetOccurrenceNoteRequest) ProtoMessage()               {}
func (*GetOccurrenceNoteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GetOccurrenceNoteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to list notes.
type ListNotesRequest struct {
	// The name field will contain the projectId for example:
	// "providers/{provider_id}
	// @Deprecated
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// This field contains the projectId for example:
	// "project/{project_id}
	Parent string `protobuf:"bytes,5,opt,name=parent" json:"parent,omitempty"`
	// The filter expression.
	Filter string `protobuf:"bytes,2,opt,name=filter" json:"filter,omitempty"`
	// Number of notes to return in the list.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
	// Token to provide to skip to a particular spot in the list.
	PageToken string `protobuf:"bytes,4,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
}

func (m *ListNotesRequest) Reset()                    { *m = ListNotesRequest{} }
func (m *ListNotesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListNotesRequest) ProtoMessage()               {}
func (*ListNotesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ListNotesRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListNotesRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *ListNotesRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *ListNotesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListNotesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// Request to delete a note
type DeleteNoteRequest struct {
	// The name of the note in the form
	// "providers/{provider_id}/notes/{note_id}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DeleteNoteRequest) Reset()                    { *m = DeleteNoteRequest{} }
func (m *DeleteNoteRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteNoteRequest) ProtoMessage()               {}
func (*DeleteNoteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *DeleteNoteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request to insert a new note
type CreateNoteRequest struct {
	// The name of the project.
	// Should be of the form "providers/{provider_id}".
	// @Deprecated
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// This field contains the projectId for example:
	// "project/{project_id}
	Parent string `protobuf:"bytes,4,opt,name=parent" json:"parent,omitempty"`
	// The ID to use for this note.
	NoteId string `protobuf:"bytes,2,opt,name=note_id,json=noteId" json:"note_id,omitempty"`
	// The Note to be inserted
	Note *Note `protobuf:"bytes,3,opt,name=note" json:"note,omitempty"`
}

func (m *CreateNoteRequest) Reset()                    { *m = CreateNoteRequest{} }
func (m *CreateNoteRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateNoteRequest) ProtoMessage()               {}
func (*CreateNoteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *CreateNoteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateNoteRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *CreateNoteRequest) GetNoteId() string {
	if m != nil {
		return m.NoteId
	}
	return ""
}

func (m *CreateNoteRequest) GetNote() *Note {
	if m != nil {
		return m.Note
	}
	return nil
}

// Request to update an existing note
type UpdateNoteRequest struct {
	// The name of the note.
	// Should be of the form "projects/{provider_id}/notes/{note_id}".
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The updated note.
	Note *Note `protobuf:"bytes,2,opt,name=note" json:"note,omitempty"`
}

func (m *UpdateNoteRequest) Reset()                    { *m = UpdateNoteRequest{} }
func (m *UpdateNoteRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateNoteRequest) ProtoMessage()               {}
func (*UpdateNoteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *UpdateNoteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateNoteRequest) GetNote() *Note {
	if m != nil {
		return m.Note
	}
	return nil
}

// Request to list occurrences.
type ListNoteOccurrencesRequest struct {
	// The name field will contain the note name for example:
	//   "provider/{provider_id}/notes/{note_id}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The filter expression.
	Filter string `protobuf:"bytes,2,opt,name=filter" json:"filter,omitempty"`
	// Number of notes to return in the list.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
	// Token to provide to skip to a particular spot in the list.
	PageToken string `protobuf:"bytes,4,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
}

func (m *ListNoteOccurrencesRequest) Reset()                    { *m = ListNoteOccurrencesRequest{} }
func (m *ListNoteOccurrencesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListNoteOccurrencesRequest) ProtoMessage()               {}
func (*ListNoteOccurrencesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ListNoteOccurrencesRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListNoteOccurrencesRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *ListNoteOccurrencesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListNoteOccurrencesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// Response including listed occurrences for a note.
type ListNoteOccurrencesResponse struct {
	// Token to receive the next page of notes.
	NextPageToken string `protobuf:"bytes,1,opt,name=nextPageToken" json:"nextPageToken,omitempty"`
	// The occurrences attached to the specified note.
	Occurrences []*Occurrence `protobuf:"bytes,2,rep,name=occurrences" json:"occurrences,omitempty"`
}

func (m *ListNoteOccurrencesResponse) Reset()                    { *m = ListNoteOccurrencesResponse{} }
func (m *ListNoteOccurrencesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListNoteOccurrencesResponse) ProtoMessage()               {}
func (*ListNoteOccurrencesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ListNoteOccurrencesResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ListNoteOccurrencesResponse) GetOccurrences() []*Occurrence {
	if m != nil {
		return m.Occurrences
	}
	return nil
}

// Response including listed notes.
type ListNotesResponse struct {
	// The next pagination token in the List response. It should be used as
	// page_token for the following request. An empty value means no more result.
	NextPageToken string `protobuf:"bytes,1,opt,name=nextPageToken" json:"nextPageToken,omitempty"`
	// The occurrences requested
	Notes []*Note `protobuf:"bytes,2,rep,name=notes" json:"notes,omitempty"`
}

func (m *ListNotesResponse) Reset()                    { *m = ListNotesResponse{} }
func (m *ListNotesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListNotesResponse) ProtoMessage()               {}
func (*ListNotesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ListNotesResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ListNotesResponse) GetNotes() []*Note {
	if m != nil {
		return m.Notes
	}
	return nil
}

// Response including listed occurrences.
type ListOccurrencesResponse struct {
	// The next pagination token in the List response. It should be used as
	// page_token for the following request. An empty value means no more results.
	NextPageToken string `protobuf:"bytes,1,opt,name=nextPageToken" json:"nextPageToken,omitempty"`
	// The occurrences requested.
	Occurrences []*Occurrence `protobuf:"bytes,2,rep,name=occurrences" json:"occurrences,omitempty"`
}

func (m *ListOccurrencesResponse) Reset()                    { *m = ListOccurrencesResponse{} }
func (m *ListOccurrencesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListOccurrencesResponse) ProtoMessage()               {}
func (*ListOccurrencesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ListOccurrencesResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ListOccurrencesResponse) GetOccurrences() []*Occurrence {
	if m != nil {
		return m.Occurrences
	}
	return nil
}

// Response including listed operations.
type ListOperationsResponse struct {
	// The next pagination token in the List response. It should be used as
	// page_token for the following request. An empty value means no more results.
	NextPageToken string `protobuf:"bytes,1,opt,name=nextPageToken" json:"nextPageToken,omitempty"`
	// The operations requested.
	Operations []*google_longrunning.Operation `protobuf:"bytes,2,rep,name=operations" json:"operations,omitempty"`
}

func (m *ListOperationsResponse) Reset()                    { *m = ListOperationsResponse{} }
func (m *ListOperationsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListOperationsResponse) ProtoMessage()               {}
func (*ListOperationsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ListOperationsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ListOperationsResponse) GetOperations() []*google_longrunning.Operation {
	if m != nil {
		return m.Operations
	}
	return nil
}

// Request for updating an existing operation
type UpdateOperationRequest struct {
	// The name of the Operation.
	// Should be of the form "projects/{provider_id}/operations/{operation_id}".
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The operation to create.
	Operation *google_longrunning.Operation `protobuf:"bytes,3,opt,name=operation" json:"operation,omitempty"`
}

func (m *UpdateOperationRequest) Reset()                    { *m = UpdateOperationRequest{} }
func (m *UpdateOperationRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateOperationRequest) ProtoMessage()               {}
func (*UpdateOperationRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *UpdateOperationRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateOperationRequest) GetOperation() *google_longrunning.Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

// Request for creating an operation
type CreateOperationRequest struct {
	// The projectId that this operation should be created under.
	Parent string `protobuf:"bytes,1,opt,name=parent" json:"parent,omitempty"`
	// The ID to use for this operation.
	OperationId string `protobuf:"bytes,2,opt,name=operation_id,json=operationId" json:"operation_id,omitempty"`
	// The operation to create.
	Operation *google_longrunning.Operation `protobuf:"bytes,3,opt,name=operation" json:"operation,omitempty"`
}

func (m *CreateOperationRequest) Reset()                    { *m = CreateOperationRequest{} }
func (m *CreateOperationRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateOperationRequest) ProtoMessage()               {}
func (*CreateOperationRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *CreateOperationRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *CreateOperationRequest) GetOperationId() string {
	if m != nil {
		return m.OperationId
	}
	return ""
}

func (m *CreateOperationRequest) GetOperation() *google_longrunning.Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

// OperationMetadata can be used to provide additional information inside a google.longrunning.operation
type OperationMetadata struct {
	// Output only. The time this operation was created.
	CreateTime *google_protobuf2.Timestamp `protobuf:"bytes,1,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Output only. The time that this operation was marked completed or failed.
	EndTime *google_protobuf2.Timestamp `protobuf:"bytes,2,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
}

func (m *OperationMetadata) Reset()                    { *m = OperationMetadata{} }
func (m *OperationMetadata) String() string            { return proto.CompactTextString(m) }
func (*OperationMetadata) ProtoMessage()               {}
func (*OperationMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *OperationMetadata) GetCreateTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *OperationMetadata) GetEndTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

// Artifact describes a build product.
type Artifact struct {
	// Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
	// container.
	Checksum string `protobuf:"bytes,1,opt,name=checksum" json:"checksum,omitempty"`
	// Artifact ID, if any; for container images, this will be a URL by digest
	// like gcr.io/projectID/imagename@sha256:123456
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// Related artifact names. This may be the path to a binary or jar file, or in
	// the case of a container build, the name used to push the container image to
	// Google Container Registry, as presented to `docker push`. Note that a
	// single Artifact ID can have multiple names, for example if two tags are
	// applied to one image.
	Names []string `protobuf:"bytes,3,rep,name=names" json:"names,omitempty"`
}

func (m *Artifact) Reset()                    { *m = Artifact{} }
func (m *Artifact) String() string            { return proto.CompactTextString(m) }
func (*Artifact) ProtoMessage()               {}
func (*Artifact) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *Artifact) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

func (m *Artifact) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Artifact) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

// Note kind that represents a logical attestation "role" or "authority".  For
// example, an organization might have one AttestationAuthority for "QA" and one
// for "build".  This Note is intended to act strictly as a grouping mechanism
// for the attached Occurrences (Attestations).  This grouping mechanism also
// provides a security boundary, since IAM ACLs gate the ability for a principle
// to attach an Occurrence to a given Note.  It also provides a single point of
// lookup to find all attached Attestation Occurrences, even if they don't all
// live in the same project.
type AttestationAuthority struct {
	Hint *AttestationAuthority_AttestationAuthorityHint `protobuf:"bytes,1,opt,name=hint" json:"hint,omitempty"`
}

func (m *AttestationAuthority) Reset()                    { *m = AttestationAuthority{} }
func (m *AttestationAuthority) String() string            { return proto.CompactTextString(m) }
func (*AttestationAuthority) ProtoMessage()               {}
func (*AttestationAuthority) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *AttestationAuthority) GetHint() *AttestationAuthority_AttestationAuthorityHint {
	if m != nil {
		return m.Hint
	}
	return nil
}

type AttestationAuthority_AttestationAuthorityHint struct {
	// The human readable name of this Attestation Authority, e.g. "qa".
	HumanReadableName string `protobuf:"bytes,1,opt,name=human_readable_name,json=humanReadableName" json:"human_readable_name,omitempty"`
}

func (m *AttestationAuthority_AttestationAuthorityHint) Reset() {
	*m = AttestationAuthority_AttestationAuthorityHint{}
}
func (m *AttestationAuthority_AttestationAuthorityHint) String() string {
	return proto.CompactTextString(m)
}
func (*AttestationAuthority_AttestationAuthorityHint) ProtoMessage() {}
func (*AttestationAuthority_AttestationAuthorityHint) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{20, 0}
}

func (m *AttestationAuthority_AttestationAuthorityHint) GetHumanReadableName() string {
	if m != nil {
		return m.HumanReadableName
	}
	return ""
}

type AttestationAuthority_Attestation struct {
	// The signature, generally over the `resource_url`, that verifies this
	// attestation.  The semantics of the signature veracity are ultimately
	// determined by the verification engine.
	//
	// Types that are valid to be assigned to Signature:
	//	*AttestationAuthority_Attestation_PgpSignedAttestation
	Signature isAttestationAuthority_Attestation_Signature `protobuf_oneof:"signature"`
}

func (m *AttestationAuthority_Attestation) Reset()         { *m = AttestationAuthority_Attestation{} }
func (m *AttestationAuthority_Attestation) String() string { return proto.CompactTextString(m) }
func (*AttestationAuthority_Attestation) ProtoMessage()    {}
func (*AttestationAuthority_Attestation) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{20, 1}
}

type isAttestationAuthority_Attestation_Signature interface {
	isAttestationAuthority_Attestation_Signature()
}

type AttestationAuthority_Attestation_PgpSignedAttestation struct {
	PgpSignedAttestation *PgpSignedAttestation `protobuf:"bytes,1,opt,name=pgp_signed_attestation,json=pgpSignedAttestation,oneof"`
}

func (*AttestationAuthority_Attestation_PgpSignedAttestation) isAttestationAuthority_Attestation_Signature() {
}

func (m *AttestationAuthority_Attestation) GetSignature() isAttestationAuthority_Attestation_Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *AttestationAuthority_Attestation) GetPgpSignedAttestation() *PgpSignedAttestation {
	if x, ok := m.GetSignature().(*AttestationAuthority_Attestation_PgpSignedAttestation); ok {
		return x.PgpSignedAttestation
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AttestationAuthority_Attestation) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AttestationAuthority_Attestation_OneofMarshaler, _AttestationAuthority_Attestation_OneofUnmarshaler, _AttestationAuthority_Attestation_OneofSizer, []interface{}{
		(*AttestationAuthority_Attestation_PgpSignedAttestation)(nil),
	}
}

func _AttestationAuthority_Attestation_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AttestationAuthority_Attestation)
	// signature
	switch x := m.Signature.(type) {
	case *AttestationAuthority_Attestation_PgpSignedAttestation:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PgpSignedAttestation); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AttestationAuthority_Attestation.Signature has unexpected type %T", x)
	}
	return nil
}

func _AttestationAuthority_Attestation_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AttestationAuthority_Attestation)
	switch tag {
	case 1: // signature.pgp_signed_attestation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PgpSignedAttestation)
		err := b.DecodeMessage(msg)
		m.Signature = &AttestationAuthority_Attestation_PgpSignedAttestation{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AttestationAuthority_Attestation_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AttestationAuthority_Attestation)
	// signature
	switch x := m.Signature.(type) {
	case *AttestationAuthority_Attestation_PgpSignedAttestation:
		s := proto.Size(x.PgpSignedAttestation)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Message encapsulating build provenance details
type BuildDetails struct {
	// The actual provenance
	Provenance *BuildProvenance `protobuf:"bytes,1,opt,name=provenance" json:"provenance,omitempty"`
	// Serialized json representation of the provenance, used in generating the
	// BuildSignature in the corresponding Result. After verifying the signature,
	// provenance_bytes can be unmarshalled and compared to the provenance to
	// confirm that it is unchanged. A base64-encoded string representation of the
	// provenance bytes is used for the signature in order to interoperate with
	// openssl which expects this format for signature verification.
	//
	// The serialized form is captured both to avoid ambiguity in how the
	// provenance is marshalled to json as well to prevent incompatibilities with
	// future changes.
	ProvenanceBytes string `protobuf:"bytes,2,opt,name=provenance_bytes,json=provenanceBytes" json:"provenance_bytes,omitempty"`
}

func (m *BuildDetails) Reset()                    { *m = BuildDetails{} }
func (m *BuildDetails) String() string            { return proto.CompactTextString(m) }
func (*BuildDetails) ProtoMessage()               {}
func (*BuildDetails) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *BuildDetails) GetProvenance() *BuildProvenance {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *BuildDetails) GetProvenanceBytes() string {
	if m != nil {
		return m.ProvenanceBytes
	}
	return ""
}

// Provenance of a build. Contains all information needed to verify the full
// details about the build from source to completion.
type BuildProvenance struct {
	// Special options applied to this build. This is a catch-all field where
	// build providers can enter any desired additional details.
	BuildOptions map[string]string `protobuf:"bytes,1,rep,name=build_options,json=buildOptions" json:"build_options,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Version string of the builder at the time this build was executed.
	BuilderVersion string `protobuf:"bytes,2,opt,name=builder_version,json=builderVersion" json:"builder_version,omitempty"`
	// Output of the build.
	BuiltArtifacts []*Artifact `protobuf:"bytes,3,rep,name=built_artifacts,json=builtArtifacts" json:"built_artifacts,omitempty"`
	// Commands requested by the build.
	Commands []*Command `protobuf:"bytes,4,rep,name=commands" json:"commands,omitempty"`
	// Time at which the build was created.
	CreateTime string `protobuf:"bytes,5,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// E-mail address of the user who initiated this build. Note that this was the
	// user's e-mail address at the time the build was initiated; this address may
	// not represent the same end-user for all time.
	Creator string `protobuf:"bytes,6,opt,name=creator" json:"creator,omitempty"`
	// Time at which execution of the build was finished.
	FinishTime string `protobuf:"bytes,7,opt,name=finish_time,json=finishTime" json:"finish_time,omitempty"`
	// Unique identifier of the build.
	Id string `protobuf:"bytes,8,opt,name=id" json:"id,omitempty"`
	// Google Cloud Storage bucket where logs were written.
	LogsBucket string `protobuf:"bytes,9,opt,name=logs_bucket,json=logsBucket" json:"logs_bucket,omitempty"`
	// ID of the project.
	ProjectId string `protobuf:"bytes,10,opt,name=project_id,json=projectId" json:"project_id,omitempty"`
	// Numerical ID of the project.
	ProjectNum string `protobuf:"bytes,11,opt,name=project_num,json=projectNum" json:"project_num,omitempty"`
	// Details of the Source input to the build.
	SourceProvenance *Source `protobuf:"bytes,12,opt,name=source_provenance,json=sourceProvenance" json:"source_provenance,omitempty"`
	// Time at which execution of the build was started.
	StartTime string `protobuf:"bytes,13,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// Trigger identifier if the build was triggered automatically; empty if not.
	TriggerId string `protobuf:"bytes,14,opt,name=trigger_id,json=triggerId" json:"trigger_id,omitempty"`
}

func (m *BuildProvenance) Reset()                    { *m = BuildProvenance{} }
func (m *BuildProvenance) String() string            { return proto.CompactTextString(m) }
func (*BuildProvenance) ProtoMessage()               {}
func (*BuildProvenance) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *BuildProvenance) GetBuildOptions() map[string]string {
	if m != nil {
		return m.BuildOptions
	}
	return nil
}

func (m *BuildProvenance) GetBuilderVersion() string {
	if m != nil {
		return m.BuilderVersion
	}
	return ""
}

func (m *BuildProvenance) GetBuiltArtifacts() []*Artifact {
	if m != nil {
		return m.BuiltArtifacts
	}
	return nil
}

func (m *BuildProvenance) GetCommands() []*Command {
	if m != nil {
		return m.Commands
	}
	return nil
}

func (m *BuildProvenance) GetCreateTime() string {
	if m != nil {
		return m.CreateTime
	}
	return ""
}

func (m *BuildProvenance) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *BuildProvenance) GetFinishTime() string {
	if m != nil {
		return m.FinishTime
	}
	return ""
}

func (m *BuildProvenance) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BuildProvenance) GetLogsBucket() string {
	if m != nil {
		return m.LogsBucket
	}
	return ""
}

func (m *BuildProvenance) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *BuildProvenance) GetProjectNum() string {
	if m != nil {
		return m.ProjectNum
	}
	return ""
}

func (m *BuildProvenance) GetSourceProvenance() *Source {
	if m != nil {
		return m.SourceProvenance
	}
	return nil
}

func (m *BuildProvenance) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *BuildProvenance) GetTriggerId() string {
	if m != nil {
		return m.TriggerId
	}
	return ""
}

// Message encapsulating signature of the verified build
type BuildSignature struct {
	// An ID for the key used to sign.  This could be either an ID for the key
	// stored in `public_key` (e.g., the ID or fingerprint for a PGP key, or the
	// CN for a cert), or a reference to an external key (e.g., a reference to a
	// key in Cloud KMS).
	KeyId   string                 `protobuf:"bytes,1,opt,name=key_id,json=keyId" json:"key_id,omitempty"`
	KeyType BuildSignature_KeyType `protobuf:"varint,2,opt,name=key_type,json=keyType,enum=grafeas.v1alpha1.api.BuildSignature_KeyType" json:"key_type,omitempty"`
	// Public key of the builder which can be used to verify that related
	// Findings are valid and unchanged.  If `key_type` is empty this defaults
	// to PEM encoded public keys.
	//
	// This field may be empty if `key_id` references an external key.
	//
	// For Cloud Container Builder based signatures this is a PEM encoded public
	// key. To verify the Cloud Container Builder signature, place the contents of
	// this field into a file (public.pem). The signature field is base64-decoded
	// into its binary representation in signature.bin, and the provenance bytes
	// from BuildDetails are base64-decoded into a binary representation in
	// signed.bin. OpenSSL can then verify the signature:
	// `openssl sha256 -verify public.pem -signature signature.bin signed.bin`
	PublicKey string `protobuf:"bytes,3,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	// Signature of the related BuildProvenance, encoded in a base64 string.
	Signature string `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
}

func (m *BuildSignature) Reset()                    { *m = BuildSignature{} }
func (m *BuildSignature) String() string            { return proto.CompactTextString(m) }
func (*BuildSignature) ProtoMessage()               {}
func (*BuildSignature) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *BuildSignature) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *BuildSignature) GetKeyType() BuildSignature_KeyType {
	if m != nil {
		return m.KeyType
	}
	return BuildSignature_UNSET
}

func (m *BuildSignature) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *BuildSignature) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

// Note holding the version of the provider's builder and the signature of
// the provenance message in linked BuildDetails.
type BuildType struct {
	// Version of the builder which produced this Note.
	BuilderVersion string `protobuf:"bytes,1,opt,name=builder_version,json=builderVersion" json:"builder_version,omitempty"`
	// Signature of the build in Occurrences pointing to the Note containing this
	// BuilderDetails.
	Signature *BuildSignature `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
}

func (m *BuildType) Reset()                    { *m = BuildType{} }
func (m *BuildType) String() string            { return proto.CompactTextString(m) }
func (*BuildType) ProtoMessage()               {}
func (*BuildType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *BuildType) GetBuilderVersion() string {
	if m != nil {
		return m.BuilderVersion
	}
	return ""
}

func (m *BuildType) GetSignature() *BuildSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Command describes a step performed as part of the build pipeline.
type Command struct {
	// Command-line arguments used when executing this Command.
	Args []string `protobuf:"bytes,1,rep,name=args" json:"args,omitempty"`
	// Working directory (relative to project source root) used when running
	// this Command.
	Dir string `protobuf:"bytes,2,opt,name=dir" json:"dir,omitempty"`
	// Environment variables set before running this Command.
	Env []string `protobuf:"bytes,3,rep,name=env" json:"env,omitempty"`
	// Optional unique identifier for this Command, used in wait_for to reference
	// this Command as a dependency.
	Id string `protobuf:"bytes,4,opt,name=id" json:"id,omitempty"`
	// Name of the command, as presented on the command line, or if the command is
	// packaged as a Docker container, as presented to `docker pull`.
	Name string `protobuf:"bytes,5,opt,name=name" json:"name,omitempty"`
	// The ID(s) of the Command(s) that this Command depends on.
	WaitFor []string `protobuf:"bytes,6,rep,name=wait_for,json=waitFor" json:"wait_for,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *Command) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Command) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

func (m *Command) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *Command) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Command) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Command) GetWaitFor() []string {
	if m != nil {
		return m.WaitFor
	}
	return nil
}

// An artifact that can be deployed in some runtime.
type Deployable struct {
	// Resource URI for the artifact being deployed.
	ResourceUri []string `protobuf:"bytes,1,rep,name=resource_uri,json=resourceUri" json:"resource_uri,omitempty"`
}

func (m *Deployable) Reset()                    { *m = Deployable{} }
func (m *Deployable) String() string            { return proto.CompactTextString(m) }
func (*Deployable) ProtoMessage()               {}
func (*Deployable) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *Deployable) GetResourceUri() []string {
	if m != nil {
		return m.ResourceUri
	}
	return nil
}

// The period during which some deployable was active in a runtime.
type Deployable_Deployment struct {
	// Address of the runtime element hosting this deployment.
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// Configuration used to create this deployment.
	Config map[string]string `protobuf:"bytes,2,rep,name=config" json:"config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Beginning of the lifetime of this deployment.
	DeployTime string `protobuf:"bytes,3,opt,name=deploy_time,json=deployTime" json:"deploy_time,omitempty"`
	// End of the lifetime of this deployment.
	UndeployTime string `protobuf:"bytes,4,opt,name=undeploy_time,json=undeployTime" json:"undeploy_time,omitempty"`
	// Identity of the user that triggered this deployment.
	UserEmail string `protobuf:"bytes,5,opt,name=user_email,json=userEmail" json:"user_email,omitempty"`
}

func (m *Deployable_Deployment) Reset()                    { *m = Deployable_Deployment{} }
func (m *Deployable_Deployment) String() string            { return proto.CompactTextString(m) }
func (*Deployable_Deployment) ProtoMessage()               {}
func (*Deployable_Deployment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26, 0} }

func (m *Deployable_Deployment) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Deployable_Deployment) GetConfig() map[string]string {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Deployable_Deployment) GetDeployTime() string {
	if m != nil {
		return m.DeployTime
	}
	return ""
}

func (m *Deployable_Deployment) GetUndeployTime() string {
	if m != nil {
		return m.UndeployTime
	}
	return ""
}

func (m *Deployable_Deployment) GetUserEmail() string {
	if m != nil {
		return m.UserEmail
	}
	return ""
}

// DockerImage holds types defining base image notes
// and derived image occurrences.
type DockerImage struct {
}

func (m *DockerImage) Reset()                    { *m = DockerImage{} }
func (m *DockerImage) String() string            { return proto.CompactTextString(m) }
func (*DockerImage) ProtoMessage()               {}
func (*DockerImage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

// Instructions from dockerfile
type DockerImage_Layer struct {
	// The recovered arguments to the Dockerfile directive.
	Arguments string                      `protobuf:"bytes,1,opt,name=arguments" json:"arguments,omitempty"`
	Directive DockerImage_Layer_Directive `protobuf:"varint,2,opt,name=directive,enum=grafeas.v1alpha1.api.DockerImage_Layer_Directive" json:"directive,omitempty"`
}

func (m *DockerImage_Layer) Reset()                    { *m = DockerImage_Layer{} }
func (m *DockerImage_Layer) String() string            { return proto.CompactTextString(m) }
func (*DockerImage_Layer) ProtoMessage()               {}
func (*DockerImage_Layer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27, 0} }

func (m *DockerImage_Layer) GetArguments() string {
	if m != nil {
		return m.Arguments
	}
	return ""
}

func (m *DockerImage_Layer) GetDirective() DockerImage_Layer_Directive {
	if m != nil {
		return m.Directive
	}
	return DockerImage_Layer_UNKNOWN_DIRECTIVE
}

// A set of properties that uniquely identify a given Docker image.
type DockerImage_Fingerprint struct {
	// The layer-id of the final layer in the Docker images v1
	// representation.
	// This field can be used as a filter in list requests.
	V1Name string `protobuf:"bytes,1,opt,name=v1_name,json=v1Name" json:"v1_name,omitempty"`
	// The ordered list of v2 blobs that represent a given image.
	V2Blob []string `protobuf:"bytes,2,rep,name=v2_blob,json=v2Blob" json:"v2_blob,omitempty"`
	// The name of the images v2 blobs computed via:
	//   [bottom] := v2_blobbottom := sha256(v2_blob[N] +   + v2_name[N+1])
	// Only the name of the final blob is kept.
	// This field can be used as a filter in list requests.
	// @OutputOnly
	V2Name string `protobuf:"bytes,3,opt,name=v2_name,json=v2Name" json:"v2_name,omitempty"`
}

func (m *DockerImage_Fingerprint) Reset()                    { *m = DockerImage_Fingerprint{} }
func (m *DockerImage_Fingerprint) String() string            { return proto.CompactTextString(m) }
func (*DockerImage_Fingerprint) ProtoMessage()               {}
func (*DockerImage_Fingerprint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27, 1} }

func (m *DockerImage_Fingerprint) GetV1Name() string {
	if m != nil {
		return m.V1Name
	}
	return ""
}

func (m *DockerImage_Fingerprint) GetV2Blob() []string {
	if m != nil {
		return m.V2Blob
	}
	return nil
}

func (m *DockerImage_Fingerprint) GetV2Name() string {
	if m != nil {
		return m.V2Name
	}
	return ""
}

// Basis describes the base image portion (Note) of the DockerImage
// relationship.  Linked occurrences are derived from this or an
// equivalent image via:
//   FROM <Basis.resource_url>
// Or an equivalent reference, e.g. a tag of the resource_url.
type DockerImage_Basis struct {
	// The fingerprint of the base image
	Fingerprint *DockerImage_Fingerprint `protobuf:"bytes,1,opt,name=fingerprint" json:"fingerprint,omitempty"`
	// The resource_url for the resource representing the basis of
	// associated occurrence images.
	ResourceUrl string `protobuf:"bytes,2,opt,name=resource_url,json=resourceUrl" json:"resource_url,omitempty"`
}

func (m *DockerImage_Basis) Reset()                    { *m = DockerImage_Basis{} }
func (m *DockerImage_Basis) String() string            { return proto.CompactTextString(m) }
func (*DockerImage_Basis) ProtoMessage()               {}
func (*DockerImage_Basis) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27, 2} }

func (m *DockerImage_Basis) GetFingerprint() *DockerImage_Fingerprint {
	if m != nil {
		return m.Fingerprint
	}
	return nil
}

func (m *DockerImage_Basis) GetResourceUrl() string {
	if m != nil {
		return m.ResourceUrl
	}
	return ""
}

// Derived describes the derived image portion (Occurrence) of the
// DockerImage relationship.  This image would be produced from a Dockerfile
// with FROM <DockerImage.Basis in attached Note>.
type DockerImage_Derived struct {
	// This contains the base image url for the derived image Occurrence
	// @OutputOnly
	BaseResourceUrl string `protobuf:"bytes,1,opt,name=base_resource_url,json=baseResourceUrl" json:"base_resource_url,omitempty"`
	// The number of layers by which this image differs from
	// the associated image basis.
	// @OutputOnly
	Distance uint32 `protobuf:"varint,2,opt,name=distance" json:"distance,omitempty"`
	// The fingerprint of the derived image
	Fingerprint *DockerImage_Fingerprint `protobuf:"bytes,3,opt,name=fingerprint" json:"fingerprint,omitempty"`
	// This contains layer-specific metadata, if populated it
	// has length distance and is ordered with [distance] being the
	// layer immediately following the base image and [1]
	// being the final layer.
	LayerInfo []*DockerImage_Layer `protobuf:"bytes,4,rep,name=layer_info,json=layerInfo" json:"layer_info,omitempty"`
}

func (m *DockerImage_Derived) Reset()                    { *m = DockerImage_Derived{} }
func (m *DockerImage_Derived) String() string            { return proto.CompactTextString(m) }
func (*DockerImage_Derived) ProtoMessage()               {}
func (*DockerImage_Derived) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27, 3} }

func (m *DockerImage_Derived) GetBaseResourceUrl() string {
	if m != nil {
		return m.BaseResourceUrl
	}
	return ""
}

func (m *DockerImage_Derived) GetDistance() uint32 {
	if m != nil {
		return m.Distance
	}
	return 0
}

func (m *DockerImage_Derived) GetFingerprint() *DockerImage_Fingerprint {
	if m != nil {
		return m.Fingerprint
	}
	return nil
}

func (m *DockerImage_Derived) GetLayerInfo() []*DockerImage_Layer {
	if m != nil {
		return m.LayerInfo
	}
	return nil
}

// Note that indicates a type of analysis and exists in a provider project to
// indicate the status of an analysis on a resource. Absence of an occurrence
// linked to this note for a resource indicates that analysis hasn't started.
type Discovery struct {
	// The kind of analysis that is handled by this discovery.
	AnalysisKind Note_Kind `protobuf:"varint,1,opt,name=analysis_kind,json=analysisKind,enum=grafeas.v1alpha1.api.Note_Kind" json:"analysis_kind,omitempty"`
}

func (m *Discovery) Reset()                    { *m = Discovery{} }
func (m *Discovery) String() string            { return proto.CompactTextString(m) }
func (*Discovery) ProtoMessage()               {}
func (*Discovery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *Discovery) GetAnalysisKind() Note_Kind {
	if m != nil {
		return m.AnalysisKind
	}
	return Note_KIND_UNSPECIFIED
}

type Discovery_Discovered struct {
	// An operation that indicates the status of the current scan.
	// @OutputOnly
	Operation *google_longrunning.Operation `protobuf:"bytes,1,opt,name=operation" json:"operation,omitempty"`
}

func (m *Discovery_Discovered) Reset()                    { *m = Discovery_Discovered{} }
func (m *Discovery_Discovered) String() string            { return proto.CompactTextString(m) }
func (*Discovery_Discovered) ProtoMessage()               {}
func (*Discovery_Discovered) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28, 0} }

func (m *Discovery_Discovered) GetOperation() *google_longrunning.Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

// Container message for hashes of byte content of files, used in Source
// messages to verify integrity of source input to the build.
type FileHashes struct {
	// Collection of file hashes.
	FileHash []*Hash `protobuf:"bytes,1,rep,name=file_hash,json=fileHash" json:"file_hash,omitempty"`
}

func (m *FileHashes) Reset()                    { *m = FileHashes{} }
func (m *FileHashes) String() string            { return proto.CompactTextString(m) }
func (*FileHashes) ProtoMessage()               {}
func (*FileHashes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *FileHashes) GetFileHash() []*Hash {
	if m != nil {
		return m.FileHash
	}
	return nil
}

// Container message for hash values.
type Hash struct {
	Type Hash_Type `protobuf:"varint,1,opt,name=type,enum=grafeas.v1alpha1.api.Hash_Type" json:"type,omitempty"`
	// The hash value.
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *Hash) Reset()                    { *m = Hash{} }
func (m *Hash) String() string            { return proto.CompactTextString(m) }
func (*Hash) ProtoMessage()               {}
func (*Hash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *Hash) GetType() Hash_Type {
	if m != nil {
		return m.Type
	}
	return Hash_NONE
}

func (m *Hash) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Note provides a detailed description of a note using information
// from the provider of the note.
type Note struct {
	// The name of the note in the form
	// "providers/{provider_id}/notes/{note_id}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// A one sentence description of this note
	ShortDescription string `protobuf:"bytes,3,opt,name=short_description,json=shortDescription" json:"short_description,omitempty"`
	// A detailed description of this note
	LongDescription string `protobuf:"bytes,4,opt,name=long_description,json=longDescription" json:"long_description,omitempty"`
	// Output only. This explicitly denotes which kind of note is specified. This
	// field can be used as a filter in list requests.
	Kind Note_Kind `protobuf:"varint,9,opt,name=kind,enum=grafeas.v1alpha1.api.Note_Kind" json:"kind,omitempty"`
	// The type of note.
	//
	// Types that are valid to be assigned to NoteType:
	//	*Note_VulnerabilityType
	//	*Note_BuildType
	//	*Note_BaseImage
	//	*Note_Package
	//	*Note_Deployable
	//	*Note_Discovery
	//	*Note_AttestationAuthority
	NoteType isNote_NoteType `protobuf_oneof:"note_type"`
	// Urls associated with this note
	RelatedUrl []*Note_RelatedUrl `protobuf:"bytes,7,rep,name=related_url,json=relatedUrl" json:"related_url,omitempty"`
	// Time of expiration for this note, null if note currently does not expire.
	ExpirationTime *google_protobuf2.Timestamp `protobuf:"bytes,10,opt,name=expiration_time,json=expirationTime" json:"expiration_time,omitempty"`
	// Output only. The time this note was created. This field can be used as a
	// filter in list requests.
	CreateTime *google_protobuf2.Timestamp `protobuf:"bytes,11,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Output only. The time this note was last updated. This field can be used as
	// a filter in list requests.
	UpdateTime *google_protobuf2.Timestamp `protobuf:"bytes,12,opt,name=update_time,json=updateTime" json:"update_time,omitempty"`
	// The name of the operation that created this note.
	OperationName string `protobuf:"bytes,15,opt,name=operation_name,json=operationName" json:"operation_name,omitempty"`
}

func (m *Note) Reset()                    { *m = Note{} }
func (m *Note) String() string            { return proto.CompactTextString(m) }
func (*Note) ProtoMessage()               {}
func (*Note) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

type isNote_NoteType interface {
	isNote_NoteType()
}

type Note_VulnerabilityType struct {
	VulnerabilityType *VulnerabilityType `protobuf:"bytes,6,opt,name=vulnerability_type,json=vulnerabilityType,oneof"`
}
type Note_BuildType struct {
	BuildType *BuildType `protobuf:"bytes,8,opt,name=build_type,json=buildType,oneof"`
}
type Note_BaseImage struct {
	BaseImage *DockerImage_Basis `protobuf:"bytes,13,opt,name=base_image,json=baseImage,oneof"`
}
type Note_Package struct {
	Package *PackageManager_Package `protobuf:"bytes,14,opt,name=package,oneof"`
}
type Note_Deployable struct {
	Deployable *Deployable `protobuf:"bytes,17,opt,name=deployable,oneof"`
}
type Note_Discovery struct {
	Discovery *Discovery `protobuf:"bytes,18,opt,name=discovery,oneof"`
}
type Note_AttestationAuthority struct {
	AttestationAuthority *AttestationAuthority `protobuf:"bytes,19,opt,name=attestation_authority,json=attestationAuthority,oneof"`
}

func (*Note_VulnerabilityType) isNote_NoteType()    {}
func (*Note_BuildType) isNote_NoteType()            {}
func (*Note_BaseImage) isNote_NoteType()            {}
func (*Note_Package) isNote_NoteType()              {}
func (*Note_Deployable) isNote_NoteType()           {}
func (*Note_Discovery) isNote_NoteType()            {}
func (*Note_AttestationAuthority) isNote_NoteType() {}

func (m *Note) GetNoteType() isNote_NoteType {
	if m != nil {
		return m.NoteType
	}
	return nil
}

func (m *Note) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Note) GetShortDescription() string {
	if m != nil {
		return m.ShortDescription
	}
	return ""
}

func (m *Note) GetLongDescription() string {
	if m != nil {
		return m.LongDescription
	}
	return ""
}

func (m *Note) GetKind() Note_Kind {
	if m != nil {
		return m.Kind
	}
	return Note_KIND_UNSPECIFIED
}

func (m *Note) GetVulnerabilityType() *VulnerabilityType {
	if x, ok := m.GetNoteType().(*Note_VulnerabilityType); ok {
		return x.VulnerabilityType
	}
	return nil
}

func (m *Note) GetBuildType() *BuildType {
	if x, ok := m.GetNoteType().(*Note_BuildType); ok {
		return x.BuildType
	}
	return nil
}

func (m *Note) GetBaseImage() *DockerImage_Basis {
	if x, ok := m.GetNoteType().(*Note_BaseImage); ok {
		return x.BaseImage
	}
	return nil
}

func (m *Note) GetPackage() *PackageManager_Package {
	if x, ok := m.GetNoteType().(*Note_Package); ok {
		return x.Package
	}
	return nil
}

func (m *Note) GetDeployable() *Deployable {
	if x, ok := m.GetNoteType().(*Note_Deployable); ok {
		return x.Deployable
	}
	return nil
}

func (m *Note) GetDiscovery() *Discovery {
	if x, ok := m.GetNoteType().(*Note_Discovery); ok {
		return x.Discovery
	}
	return nil
}

func (m *Note) GetAttestationAuthority() *AttestationAuthority {
	if x, ok := m.GetNoteType().(*Note_AttestationAuthority); ok {
		return x.AttestationAuthority
	}
	return nil
}

func (m *Note) GetRelatedUrl() []*Note_RelatedUrl {
	if m != nil {
		return m.RelatedUrl
	}
	return nil
}

func (m *Note) GetExpirationTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.ExpirationTime
	}
	return nil
}

func (m *Note) GetCreateTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *Note) GetUpdateTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.UpdateTime
	}
	return nil
}

func (m *Note) GetOperationName() string {
	if m != nil {
		return m.OperationName
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Note) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Note_OneofMarshaler, _Note_OneofUnmarshaler, _Note_OneofSizer, []interface{}{
		(*Note_VulnerabilityType)(nil),
		(*Note_BuildType)(nil),
		(*Note_BaseImage)(nil),
		(*Note_Package)(nil),
		(*Note_Deployable)(nil),
		(*Note_Discovery)(nil),
		(*Note_AttestationAuthority)(nil),
	}
}

func _Note_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Note)
	// note_type
	switch x := m.NoteType.(type) {
	case *Note_VulnerabilityType:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VulnerabilityType); err != nil {
			return err
		}
	case *Note_BuildType:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BuildType); err != nil {
			return err
		}
	case *Note_BaseImage:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BaseImage); err != nil {
			return err
		}
	case *Note_Package:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Package); err != nil {
			return err
		}
	case *Note_Deployable:
		b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Deployable); err != nil {
			return err
		}
	case *Note_Discovery:
		b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Discovery); err != nil {
			return err
		}
	case *Note_AttestationAuthority:
		b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AttestationAuthority); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Note.NoteType has unexpected type %T", x)
	}
	return nil
}

func _Note_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Note)
	switch tag {
	case 6: // note_type.vulnerability_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VulnerabilityType)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_VulnerabilityType{msg}
		return true, err
	case 8: // note_type.build_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BuildType)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_BuildType{msg}
		return true, err
	case 13: // note_type.base_image
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImage_Basis)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_BaseImage{msg}
		return true, err
	case 14: // note_type.package
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PackageManager_Package)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_Package{msg}
		return true, err
	case 17: // note_type.deployable
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Deployable)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_Deployable{msg}
		return true, err
	case 18: // note_type.discovery
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Discovery)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_Discovery{msg}
		return true, err
	case 19: // note_type.attestation_authority
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AttestationAuthority)
		err := b.DecodeMessage(msg)
		m.NoteType = &Note_AttestationAuthority{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Note_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Note)
	// note_type
	switch x := m.NoteType.(type) {
	case *Note_VulnerabilityType:
		s := proto.Size(x.VulnerabilityType)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_BuildType:
		s := proto.Size(x.BuildType)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_BaseImage:
		s := proto.Size(x.BaseImage)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_Package:
		s := proto.Size(x.Package)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_Deployable:
		s := proto.Size(x.Deployable)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_Discovery:
		s := proto.Size(x.Discovery)
		n += proto.SizeVarint(18<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Note_AttestationAuthority:
		s := proto.Size(x.AttestationAuthority)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Metadata for any related url information
type Note_RelatedUrl struct {
	// Specific url to associate with the note
	Url string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	// Label to describe usage of the url
	Label string `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
}

func (m *Note_RelatedUrl) Reset()                    { *m = Note_RelatedUrl{} }
func (m *Note_RelatedUrl) String() string            { return proto.CompactTextString(m) }
func (*Note_RelatedUrl) ProtoMessage()               {}
func (*Note_RelatedUrl) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31, 0} }

func (m *Note_RelatedUrl) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Note_RelatedUrl) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

// Occurrence includes information about analysis occurrences for an image.
type Occurrence struct {
	// Output only. The name of the occurrence in the form
	// "projects/{project_id}/occurrences/{occurrence_id}"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The unique url of the image or container for which the occurrence applies.
	// Example: https://gcr.io/project/image@sha256:foo
	// This field can be used as a filter in list requests.
	ResourceUrl string `protobuf:"bytes,2,opt,name=resource_url,json=resourceUrl" json:"resource_url,omitempty"`
	// An analysis note associated with this image, in the form
	// "providers/{provider_id}/notes/{note_id}"
	// This field can be used as a filter in list requests.
	NoteName string `protobuf:"bytes,3,opt,name=note_name,json=noteName" json:"note_name,omitempty"`
	// Output only. This explicitly denotes which of the occurrence details is
	// specified. This field can be used as a filter in list requests.
	Kind Note_Kind `protobuf:"varint,6,opt,name=kind,enum=grafeas.v1alpha1.api.Note_Kind" json:"kind,omitempty"`
	// Describes the details of the vulnerability note found in this resource.
	//
	// Types that are valid to be assigned to Details:
	//	*Occurrence_VulnerabilityDetails
	//	*Occurrence_BuildDetails
	//	*Occurrence_DerivedImage
	//	*Occurrence_Installation
	//	*Occurrence_Deployment
	//	*Occurrence_Discovered
	//	*Occurrence_Attestation
	Details isOccurrence_Details `protobuf_oneof:"details"`
	// A description of actions that can be taken to remedy the note
	Remediation string `protobuf:"bytes,5,opt,name=remediation" json:"remediation,omitempty"`
	// Output only. The time this occurrence was created.
	CreateTime *google_protobuf2.Timestamp `protobuf:"bytes,9,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Output only. The time this occurrence was last updated.
	UpdateTime *google_protobuf2.Timestamp `protobuf:"bytes,10,opt,name=update_time,json=updateTime" json:"update_time,omitempty"`
	// The name of the operation that created this note.
	OperationName string `protobuf:"bytes,13,opt,name=operation_name,json=operationName" json:"operation_name,omitempty"`
}

func (m *Occurrence) Reset()                    { *m = Occurrence{} }
func (m *Occurrence) String() string            { return proto.CompactTextString(m) }
func (*Occurrence) ProtoMessage()               {}
func (*Occurrence) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

type isOccurrence_Details interface {
	isOccurrence_Details()
}

type Occurrence_VulnerabilityDetails struct {
	VulnerabilityDetails *VulnerabilityType_VulnerabilityDetails `protobuf:"bytes,8,opt,name=vulnerability_details,json=vulnerabilityDetails,oneof"`
}
type Occurrence_BuildDetails struct {
	BuildDetails *BuildDetails `protobuf:"bytes,7,opt,name=build_details,json=buildDetails,oneof"`
}
type Occurrence_DerivedImage struct {
	DerivedImage *DockerImage_Derived `protobuf:"bytes,11,opt,name=derived_image,json=derivedImage,oneof"`
}
type Occurrence_Installation struct {
	Installation *PackageManager_Installation `protobuf:"bytes,12,opt,name=installation,oneof"`
}
type Occurrence_Deployment struct {
	Deployment *Deployable_Deployment `protobuf:"bytes,14,opt,name=deployment,oneof"`
}
type Occurrence_Discovered struct {
	Discovered *Discovery_Discovered `protobuf:"bytes,15,opt,name=discovered,oneof"`
}
type Occurrence_Attestation struct {
	Attestation *AttestationAuthority_Attestation `protobuf:"bytes,16,opt,name=attestation,oneof"`
}

func (*Occurrence_VulnerabilityDetails) isOccurrence_Details() {}
func (*Occurrence_BuildDetails) isOccurrence_Details()         {}
func (*Occurrence_DerivedImage) isOccurrence_Details()         {}
func (*Occurrence_Installation) isOccurrence_Details()         {}
func (*Occurrence_Deployment) isOccurrence_Details()           {}
func (*Occurrence_Discovered) isOccurrence_Details()           {}
func (*Occurrence_Attestation) isOccurrence_Details()          {}

func (m *Occurrence) GetDetails() isOccurrence_Details {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *Occurrence) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Occurrence) GetResourceUrl() string {
	if m != nil {
		return m.ResourceUrl
	}
	return ""
}

func (m *Occurrence) GetNoteName() string {
	if m != nil {
		return m.NoteName
	}
	return ""
}

func (m *Occurrence) GetKind() Note_Kind {
	if m != nil {
		return m.Kind
	}
	return Note_KIND_UNSPECIFIED
}

func (m *Occurrence) GetVulnerabilityDetails() *VulnerabilityType_VulnerabilityDetails {
	if x, ok := m.GetDetails().(*Occurrence_VulnerabilityDetails); ok {
		return x.VulnerabilityDetails
	}
	return nil
}

func (m *Occurrence) GetBuildDetails() *BuildDetails {
	if x, ok := m.GetDetails().(*Occurrence_BuildDetails); ok {
		return x.BuildDetails
	}
	return nil
}

func (m *Occurrence) GetDerivedImage() *DockerImage_Derived {
	if x, ok := m.GetDetails().(*Occurrence_DerivedImage); ok {
		return x.DerivedImage
	}
	return nil
}

func (m *Occurrence) GetInstallation() *PackageManager_Installation {
	if x, ok := m.GetDetails().(*Occurrence_Installation); ok {
		return x.Installation
	}
	return nil
}

func (m *Occurrence) GetDeployment() *Deployable_Deployment {
	if x, ok := m.GetDetails().(*Occurrence_Deployment); ok {
		return x.Deployment
	}
	return nil
}

func (m *Occurrence) GetDiscovered() *Discovery_Discovered {
	if x, ok := m.GetDetails().(*Occurrence_Discovered); ok {
		return x.Discovered
	}
	return nil
}

func (m *Occurrence) GetAttestation() *AttestationAuthority_Attestation {
	if x, ok := m.GetDetails().(*Occurrence_Attestation); ok {
		return x.Attestation
	}
	return nil
}

func (m *Occurrence) GetRemediation() string {
	if m != nil {
		return m.Remediation
	}
	return ""
}

func (m *Occurrence) GetCreateTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *Occurrence) GetUpdateTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.UpdateTime
	}
	return nil
}

func (m *Occurrence) GetOperationName() string {
	if m != nil {
		return m.OperationName
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Occurrence) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Occurrence_OneofMarshaler, _Occurrence_OneofUnmarshaler, _Occurrence_OneofSizer, []interface{}{
		(*Occurrence_VulnerabilityDetails)(nil),
		(*Occurrence_BuildDetails)(nil),
		(*Occurrence_DerivedImage)(nil),
		(*Occurrence_Installation)(nil),
		(*Occurrence_Deployment)(nil),
		(*Occurrence_Discovered)(nil),
		(*Occurrence_Attestation)(nil),
	}
}

func _Occurrence_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Occurrence)
	// details
	switch x := m.Details.(type) {
	case *Occurrence_VulnerabilityDetails:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VulnerabilityDetails); err != nil {
			return err
		}
	case *Occurrence_BuildDetails:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BuildDetails); err != nil {
			return err
		}
	case *Occurrence_DerivedImage:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DerivedImage); err != nil {
			return err
		}
	case *Occurrence_Installation:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Installation); err != nil {
			return err
		}
	case *Occurrence_Deployment:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Deployment); err != nil {
			return err
		}
	case *Occurrence_Discovered:
		b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Discovered); err != nil {
			return err
		}
	case *Occurrence_Attestation:
		b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Attestation); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Occurrence.Details has unexpected type %T", x)
	}
	return nil
}

func _Occurrence_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Occurrence)
	switch tag {
	case 8: // details.vulnerability_details
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VulnerabilityType_VulnerabilityDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_VulnerabilityDetails{msg}
		return true, err
	case 7: // details.build_details
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BuildDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_BuildDetails{msg}
		return true, err
	case 11: // details.derived_image
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImage_Derived)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_DerivedImage{msg}
		return true, err
	case 12: // details.installation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PackageManager_Installation)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_Installation{msg}
		return true, err
	case 14: // details.deployment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Deployable_Deployment)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_Deployment{msg}
		return true, err
	case 15: // details.discovered
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Discovery_Discovered)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_Discovered{msg}
		return true, err
	case 16: // details.attestation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AttestationAuthority_Attestation)
		err := b.DecodeMessage(msg)
		m.Details = &Occurrence_Attestation{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Occurrence_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Occurrence)
	// details
	switch x := m.Details.(type) {
	case *Occurrence_VulnerabilityDetails:
		s := proto.Size(x.VulnerabilityDetails)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_BuildDetails:
		s := proto.Size(x.BuildDetails)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_DerivedImage:
		s := proto.Size(x.DerivedImage)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_Installation:
		s := proto.Size(x.Installation)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_Deployment:
		s := proto.Size(x.Deployment)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_Discovered:
		s := proto.Size(x.Discovered)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Occurrence_Attestation:
		s := proto.Size(x.Attestation)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// PackageManager provides metadata about available / installed packages.
type PackageManager struct {
}

func (m *PackageManager) Reset()                    { *m = PackageManager{} }
func (m *PackageManager) String() string            { return proto.CompactTextString(m) }
func (*PackageManager) ProtoMessage()               {}
func (*PackageManager) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

// This represents a particular package that is distributed over
// various channels.
// e.g. glibc (aka libc6) is distributed by many, at various versions.
type PackageManager_Package struct {
	// The various channels by which a package is distributed.
	Distribution []*PackageManager_Distribution `protobuf:"bytes,1,rep,name=distribution" json:"distribution,omitempty"`
	// The name of the package.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
}

func (m *PackageManager_Package) Reset()                    { *m = PackageManager_Package{} }
func (m *PackageManager_Package) String() string            { return proto.CompactTextString(m) }
func (*PackageManager_Package) ProtoMessage()               {}
func (*PackageManager_Package) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33, 0} }

func (m *PackageManager_Package) GetDistribution() []*PackageManager_Distribution {
	if m != nil {
		return m.Distribution
	}
	return nil
}

func (m *PackageManager_Package) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// This represents a particular channel of distribution for a given package.
// e.g. Debian's jessie-backports dpkg mirror
type PackageManager_Distribution struct {
	Architecture PackageManager_Distribution_Architecture `protobuf:"varint,1,opt,name=architecture,enum=grafeas.v1alpha1.api.PackageManager_Distribution_Architecture" json:"architecture,omitempty"`
	// The cpe_uri in [cpe format](https://cpe.mitre.org/specification/)
	// denoting the package manager version distributing a package.
	CpeUri string `protobuf:"bytes,2,opt,name=cpe_uri,json=cpeUri" json:"cpe_uri,omitempty"`
	// The distribution channel-specific description of this package.
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// The latest available version of this package in
	// this distribution channel.
	LatestVersion *PackageManager_Version `protobuf:"bytes,4,opt,name=latest_version,json=latestVersion" json:"latest_version,omitempty"`
	// A freeform string denoting the maintainer of this package.
	Maintainer string `protobuf:"bytes,5,opt,name=maintainer" json:"maintainer,omitempty"`
	// The distribution channel-specific homepage for this package.
	Url string `protobuf:"bytes,6,opt,name=url" json:"url,omitempty"`
}

func (m *PackageManager_Distribution) Reset()                    { *m = PackageManager_Distribution{} }
func (m *PackageManager_Distribution) String() string            { return proto.CompactTextString(m) }
func (*PackageManager_Distribution) ProtoMessage()               {}
func (*PackageManager_Distribution) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33, 1} }

func (m *PackageManager_Distribution) GetArchitecture() PackageManager_Distribution_Architecture {
	if m != nil {
		return m.Architecture
	}
	return PackageManager_Distribution_UNKNOWN
}

func (m *PackageManager_Distribution) GetCpeUri() string {
	if m != nil {
		return m.CpeUri
	}
	return ""
}

func (m *PackageManager_Distribution) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PackageManager_Distribution) GetLatestVersion() *PackageManager_Version {
	if m != nil {
		return m.LatestVersion
	}
	return nil
}

func (m *PackageManager_Distribution) GetMaintainer() string {
	if m != nil {
		return m.Maintainer
	}
	return ""
}

func (m *PackageManager_Distribution) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// Version contains structured information about the version of the package.
// For a discussion of this in Debian/Ubuntu:
// http://serverfault.com/questions/604541/debian-packages-version-convention
// For a discussion of this in Redhat/Fedora/Centos:
// http://blog.jasonantman.com/2014/07/how-yum-and-rpm-compare-versions/
type PackageManager_Version struct {
	// Used to correct mistakes in the version numbering scheme.
	Epoch int32 `protobuf:"varint,1,opt,name=epoch" json:"epoch,omitempty"`
	// The main part of the version name.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The iteration of the package build from the above version.
	Revision string `protobuf:"bytes,3,opt,name=revision" json:"revision,omitempty"`
	// Distinguish between sentinel MIN/MAX versions and normal versions.
	// If kind is not NORMAL, then the other fields are ignored.
	Kind PackageManager_Version_VersionKind `protobuf:"varint,5,opt,name=kind,enum=grafeas.v1alpha1.api.PackageManager_Version_VersionKind" json:"kind,omitempty"`
}

func (m *PackageManager_Version) Reset()                    { *m = PackageManager_Version{} }
func (m *PackageManager_Version) String() string            { return proto.CompactTextString(m) }
func (*PackageManager_Version) ProtoMessage()               {}
func (*PackageManager_Version) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33, 2} }

func (m *PackageManager_Version) GetEpoch() int32 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *PackageManager_Version) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PackageManager_Version) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

func (m *PackageManager_Version) GetKind() PackageManager_Version_VersionKind {
	if m != nil {
		return m.Kind
	}
	return PackageManager_Version_NORMAL
}

// An occurrence of a particular package installation found within a
// system's filesystem.
// e.g. glibc was found in /var/lib/dpkg/status
type PackageManager_Location struct {
	// The cpe_uri in [cpe format](https://cpe.mitre.org/specification/)
	// denoting the package manager version distributing a package.
	CpeUri string `protobuf:"bytes,1,opt,name=cpe_uri,json=cpeUri" json:"cpe_uri,omitempty"`
	// The path from which we gathered that this package/version is installed.
	Path string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// The version installed at this location.
	Version *VulnerabilityType_Version `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
}

func (m *PackageManager_Location) Reset()                    { *m = PackageManager_Location{} }
func (m *PackageManager_Location) String() string            { return proto.CompactTextString(m) }
func (*PackageManager_Location) ProtoMessage()               {}
func (*PackageManager_Location) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33, 3} }

func (m *PackageManager_Location) GetCpeUri() string {
	if m != nil {
		return m.CpeUri
	}
	return ""
}

func (m *PackageManager_Location) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *PackageManager_Location) GetVersion() *VulnerabilityType_Version {
	if m != nil {
		return m.Version
	}
	return nil
}

// This represents how a particular software package may be installed on
// a system.
type PackageManager_Installation struct {
	// The name of the installed package.
	// @OutputOnly
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// All of the places within the filesystem versions of this package
	// have been found.
	Location []*PackageManager_Location `protobuf:"bytes,2,rep,name=location" json:"location,omitempty"`
}

func (m *PackageManager_Installation) Reset()                    { *m = PackageManager_Installation{} }
func (m *PackageManager_Installation) String() string            { return proto.CompactTextString(m) }
func (*PackageManager_Installation) ProtoMessage()               {}
func (*PackageManager_Installation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33, 4} }

func (m *PackageManager_Installation) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PackageManager_Installation) GetLocation() []*PackageManager_Location {
	if m != nil {
		return m.Location
	}
	return nil
}

// An attestation wrapper with a PGP-compatible signature.
// This message only supports ATTACHED signatures, where the payload that is
// signed is included alongside the signature itself in the same file.
type PgpSignedAttestation struct {
	// The raw content of the signature, as output by gpg or equivalent.  Since
	// this message only supports attached signatures, the payload that was signed
	// must be attached. While the signature format supported is dependent on the
	// verification implementation, currently only ASCII-armored (`--armor` to
	// gpg), non-clearsigned (`--sign` rather than `--clearsign` to gpg) are
	// supported.
	// Concretely, `gpg --sign --armor --output=signature.gpg payload.json` will
	// create the signature content expected in this field in `signature.gpg` for
	// the `payload.json` attestation payload.
	Signature string `protobuf:"bytes,1,opt,name=signature" json:"signature,omitempty"`
	// Type (e.g. schema) of the attestation payload that was signed.
	// The verifier must ensure that the provided type is one that the verifier
	// supports, and that the attestation payload is a valid instantiation of that
	// type (e.g. by validating a JSON schema).
	ContentType PgpSignedAttestation_ContentType `protobuf:"varint,3,opt,name=content_type,json=contentType,enum=grafeas.v1alpha1.api.PgpSignedAttestation_ContentType" json:"content_type,omitempty"`
	// This field is used by verifiers to select the public key used to validate
	// the signature.  Note that the policy of the verifier ultimately determines
	// which public keys verify a signature based on the context of the
	// verification.  There is no guarantee validation will succeed if the
	// verifier has no key matching this ID, even if it has a key under a
	// different ID that would verify the signature. Note that this ID should also
	// be present in the signature content above, but that is not expected to be
	// used by the verifier.
	//
	// Types that are valid to be assigned to KeyId:
	//	*PgpSignedAttestation_PgpKeyId
	KeyId isPgpSignedAttestation_KeyId `protobuf_oneof:"key_id"`
}

func (m *PgpSignedAttestation) Reset()                    { *m = PgpSignedAttestation{} }
func (m *PgpSignedAttestation) String() string            { return proto.CompactTextString(m) }
func (*PgpSignedAttestation) ProtoMessage()               {}
func (*PgpSignedAttestation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

type isPgpSignedAttestation_KeyId interface {
	isPgpSignedAttestation_KeyId()
}

type PgpSignedAttestation_PgpKeyId struct {
	PgpKeyId string `protobuf:"bytes,2,opt,name=pgp_key_id,json=pgpKeyId,oneof"`
}

func (*PgpSignedAttestation_PgpKeyId) isPgpSignedAttestation_KeyId() {}

func (m *PgpSignedAttestation) GetKeyId() isPgpSignedAttestation_KeyId {
	if m != nil {
		return m.KeyId
	}
	return nil
}

func (m *PgpSignedAttestation) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *PgpSignedAttestation) GetContentType() PgpSignedAttestation_ContentType {
	if m != nil {
		return m.ContentType
	}
	return PgpSignedAttestation_CONTENT_TYPE_UNSPECIFIED
}

func (m *PgpSignedAttestation) GetPgpKeyId() string {
	if x, ok := m.GetKeyId().(*PgpSignedAttestation_PgpKeyId); ok {
		return x.PgpKeyId
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PgpSignedAttestation) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PgpSignedAttestation_OneofMarshaler, _PgpSignedAttestation_OneofUnmarshaler, _PgpSignedAttestation_OneofSizer, []interface{}{
		(*PgpSignedAttestation_PgpKeyId)(nil),
	}
}

func _PgpSignedAttestation_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PgpSignedAttestation)
	// key_id
	switch x := m.KeyId.(type) {
	case *PgpSignedAttestation_PgpKeyId:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.PgpKeyId)
	case nil:
	default:
		return fmt.Errorf("PgpSignedAttestation.KeyId has unexpected type %T", x)
	}
	return nil
}

func _PgpSignedAttestation_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PgpSignedAttestation)
	switch tag {
	case 2: // key_id.pgp_key_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.KeyId = &PgpSignedAttestation_PgpKeyId{x}
		return true, err
	default:
		return false, nil
	}
}

func _PgpSignedAttestation_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PgpSignedAttestation)
	// key_id
	switch x := m.KeyId.(type) {
	case *PgpSignedAttestation_PgpKeyId:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PgpKeyId)))
		n += len(x.PgpKeyId)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Source describes the location of the source used for the build.
type Source struct {
	// Source location information.
	//
	// Types that are valid to be assigned to Source:
	//	*Source_StorageSource
	//	*Source_RepoSource
	Source isSource_Source `protobuf_oneof:"source"`
	// If provided, the input binary artifacts for the build came from this
	// location.
	ArtifactStorageSource *StorageSource `protobuf:"bytes,4,opt,name=artifact_storage_source,json=artifactStorageSource" json:"artifact_storage_source,omitempty"`
	// If provided, the source code used for the build came from this location.
	SourceContext *google_devtools_source_v1.ExtendedSourceContext `protobuf:"bytes,5,opt,name=source_context,json=sourceContext" json:"source_context,omitempty"`
	// If provided, some of the source code used for the build may be found in
	// these locations, in the case where the source repository had multiple
	// remotes or submodules. This list will not include the context specified in
	// the source_context field.
	AdditionalSourceContexts []*google_devtools_source_v1.ExtendedSourceContext `protobuf:"bytes,6,rep,name=additional_source_contexts,json=additionalSourceContexts" json:"additional_source_contexts,omitempty"`
	// Hash(es) of the build source, which can be used to verify that the original
	// source integrity was maintained in the build.
	//
	// The keys to this map are file paths used as build source and the values
	// contain the hash values for those files.
	//
	// If the build source came in a single package such as a gzipped tarfile
	// (.tar.gz), the FileHash will be for the single path to that file.
	FileHashes map[string]*FileHashes `protobuf:"bytes,3,rep,name=file_hashes,json=fileHashes" json:"file_hashes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Source) Reset()                    { *m = Source{} }
func (m *Source) String() string            { return proto.CompactTextString(m) }
func (*Source) ProtoMessage()               {}
func (*Source) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

type isSource_Source interface {
	isSource_Source()
}

type Source_StorageSource struct {
	StorageSource *StorageSource `protobuf:"bytes,1,opt,name=storage_source,json=storageSource,oneof"`
}
type Source_RepoSource struct {
	RepoSource *RepoSource `protobuf:"bytes,2,opt,name=repo_source,json=repoSource,oneof"`
}

func (*Source_StorageSource) isSource_Source() {}
func (*Source_RepoSource) isSource_Source()    {}

func (m *Source) GetSource() isSource_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Source) GetStorageSource() *StorageSource {
	if x, ok := m.GetSource().(*Source_StorageSource); ok {
		return x.StorageSource
	}
	return nil
}

func (m *Source) GetRepoSource() *RepoSource {
	if x, ok := m.GetSource().(*Source_RepoSource); ok {
		return x.RepoSource
	}
	return nil
}

func (m *Source) GetArtifactStorageSource() *StorageSource {
	if m != nil {
		return m.ArtifactStorageSource
	}
	return nil
}

func (m *Source) GetSourceContext() *google_devtools_source_v1.ExtendedSourceContext {
	if m != nil {
		return m.SourceContext
	}
	return nil
}

func (m *Source) GetAdditionalSourceContexts() []*google_devtools_source_v1.ExtendedSourceContext {
	if m != nil {
		return m.AdditionalSourceContexts
	}
	return nil
}

func (m *Source) GetFileHashes() map[string]*FileHashes {
	if m != nil {
		return m.FileHashes
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Source) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Source_OneofMarshaler, _Source_OneofUnmarshaler, _Source_OneofSizer, []interface{}{
		(*Source_StorageSource)(nil),
		(*Source_RepoSource)(nil),
	}
}

func _Source_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Source)
	// source
	switch x := m.Source.(type) {
	case *Source_StorageSource:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageSource); err != nil {
			return err
		}
	case *Source_RepoSource:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RepoSource); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Source.Source has unexpected type %T", x)
	}
	return nil
}

func _Source_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Source)
	switch tag {
	case 1: // source.storage_source
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StorageSource)
		err := b.DecodeMessage(msg)
		m.Source = &Source_StorageSource{msg}
		return true, err
	case 2: // source.repo_source
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RepoSource)
		err := b.DecodeMessage(msg)
		m.Source = &Source_RepoSource{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Source_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Source)
	// source
	switch x := m.Source.(type) {
	case *Source_StorageSource:
		s := proto.Size(x.StorageSource)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Source_RepoSource:
		s := proto.Size(x.RepoSource)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RepoSource describes the location of the source in a Google Cloud Source
// Repository.
type RepoSource struct {
	// ID of the project that owns the repo.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId" json:"project_id,omitempty"`
	// Name of the repo.
	RepoName string `protobuf:"bytes,2,opt,name=repo_name,json=repoName" json:"repo_name,omitempty"`
	// A revision within the source repository must be specified in
	// one of these ways.
	//
	// Types that are valid to be assigned to Revision:
	//	*RepoSource_BranchName
	//	*RepoSource_TagName
	//	*RepoSource_CommitSha
	Revision isRepoSource_Revision `protobuf_oneof:"revision"`
}

func (m *RepoSource) Reset()                    { *m = RepoSource{} }
func (m *RepoSource) String() string            { return proto.CompactTextString(m) }
func (*RepoSource) ProtoMessage()               {}
func (*RepoSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

type isRepoSource_Revision interface {
	isRepoSource_Revision()
}

type RepoSource_BranchName struct {
	BranchName string `protobuf:"bytes,3,opt,name=branch_name,json=branchName,oneof"`
}
type RepoSource_TagName struct {
	TagName string `protobuf:"bytes,4,opt,name=tag_name,json=tagName,oneof"`
}
type RepoSource_CommitSha struct {
	CommitSha string `protobuf:"bytes,5,opt,name=commit_sha,json=commitSha,oneof"`
}

func (*RepoSource_BranchName) isRepoSource_Revision() {}
func (*RepoSource_TagName) isRepoSource_Revision()    {}
func (*RepoSource_CommitSha) isRepoSource_Revision()  {}

func (m *RepoSource) GetRevision() isRepoSource_Revision {
	if m != nil {
		return m.Revision
	}
	return nil
}

func (m *RepoSource) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *RepoSource) GetRepoName() string {
	if m != nil {
		return m.RepoName
	}
	return ""
}

func (m *RepoSource) GetBranchName() string {
	if x, ok := m.GetRevision().(*RepoSource_BranchName); ok {
		return x.BranchName
	}
	return ""
}

func (m *RepoSource) GetTagName() string {
	if x, ok := m.GetRevision().(*RepoSource_TagName); ok {
		return x.TagName
	}
	return ""
}

func (m *RepoSource) GetCommitSha() string {
	if x, ok := m.GetRevision().(*RepoSource_CommitSha); ok {
		return x.CommitSha
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RepoSource) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RepoSource_OneofMarshaler, _RepoSource_OneofUnmarshaler, _RepoSource_OneofSizer, []interface{}{
		(*RepoSource_BranchName)(nil),
		(*RepoSource_TagName)(nil),
		(*RepoSource_CommitSha)(nil),
	}
}

func _RepoSource_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RepoSource)
	// revision
	switch x := m.Revision.(type) {
	case *RepoSource_BranchName:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.BranchName)
	case *RepoSource_TagName:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.TagName)
	case *RepoSource_CommitSha:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.CommitSha)
	case nil:
	default:
		return fmt.Errorf("RepoSource.Revision has unexpected type %T", x)
	}
	return nil
}

func _RepoSource_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RepoSource)
	switch tag {
	case 3: // revision.branch_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Revision = &RepoSource_BranchName{x}
		return true, err
	case 4: // revision.tag_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Revision = &RepoSource_TagName{x}
		return true, err
	case 5: // revision.commit_sha
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Revision = &RepoSource_CommitSha{x}
		return true, err
	default:
		return false, nil
	}
}

func _RepoSource_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RepoSource)
	// revision
	switch x := m.Revision.(type) {
	case *RepoSource_BranchName:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.BranchName)))
		n += len(x.BranchName)
	case *RepoSource_TagName:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.TagName)))
		n += len(x.TagName)
	case *RepoSource_CommitSha:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.CommitSha)))
		n += len(x.CommitSha)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// StorageSource describes the location of the source in an archive file in
// Google Cloud Storage.
type StorageSource struct {
	// Google Cloud Storage bucket containing source (see [Bucket Name
	// Requirements]
	// (https://cloud.google.com/storage/docs/bucket-naming#requirements)).
	Bucket string `protobuf:"bytes,1,opt,name=bucket" json:"bucket,omitempty"`
	// Google Cloud Storage generation for the object.
	Generation string `protobuf:"bytes,2,opt,name=generation" json:"generation,omitempty"`
	// Google Cloud Storage object containing source.
	Object string `protobuf:"bytes,3,opt,name=object" json:"object,omitempty"`
}

func (m *StorageSource) Reset()                    { *m = StorageSource{} }
func (m *StorageSource) String() string            { return proto.CompactTextString(m) }
func (*StorageSource) ProtoMessage()               {}
func (*StorageSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *StorageSource) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *StorageSource) GetGeneration() string {
	if m != nil {
		return m.Generation
	}
	return ""
}

func (m *StorageSource) GetObject() string {
	if m != nil {
		return m.Object
	}
	return ""
}

// VulnerabilityType provides metadata about a security vulnerability.
type VulnerabilityType struct {
	// The CVSS score for this Vulnerability.
	CvssScore float32 `protobuf:"fixed32,2,opt,name=cvss_score,json=cvssScore" json:"cvss_score,omitempty"`
	// Note provider assigned impact of the vulnerability
	Severity VulnerabilityType_Severity `protobuf:"varint,3,opt,name=severity,enum=grafeas.v1alpha1.api.VulnerabilityType_Severity" json:"severity,omitempty"`
	// All information about the package to specifically identify this
	// vulnerability. One entry per (version range and cpe_uri) the
	// package vulnerability has manifested in.
	Details []*VulnerabilityType_Detail `protobuf:"bytes,4,rep,name=details" json:"details,omitempty"`
}

func (m *VulnerabilityType) Reset()                    { *m = VulnerabilityType{} }
func (m *VulnerabilityType) String() string            { return proto.CompactTextString(m) }
func (*VulnerabilityType) ProtoMessage()               {}
func (*VulnerabilityType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *VulnerabilityType) GetCvssScore() float32 {
	if m != nil {
		return m.CvssScore
	}
	return 0
}

func (m *VulnerabilityType) GetSeverity() VulnerabilityType_Severity {
	if m != nil {
		return m.Severity
	}
	return VulnerabilityType_SEVERITY_UNSPECIFIED
}

func (m *VulnerabilityType) GetDetails() []*VulnerabilityType_Detail {
	if m != nil {
		return m.Details
	}
	return nil
}

// Version contains structured information about the version of the package.
// For a discussion of this in Debian/Ubuntu:
// http://serverfault.com/questions/604541/debian-packages-version-convention
// For a discussion of this in Redhat/Fedora/Centos:
// http://blog.jasonantman.com/2014/07/how-yum-and-rpm-compare-versions/
type VulnerabilityType_Version struct {
	// Used to correct mistakes in the version numbering scheme.
	Epoch int32 `protobuf:"varint,1,opt,name=epoch" json:"epoch,omitempty"`
	// The main part of the version name.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The iteration of the package build from the above version.
	Revision string `protobuf:"bytes,3,opt,name=revision" json:"revision,omitempty"`
	// Distinguish between sentinel MIN/MAX versions and normal versions.
	// If kind is not NORMAL, then the other fields are ignored.
	Kind VulnerabilityType_Version_VersionKind `protobuf:"varint,5,opt,name=kind,enum=grafeas.v1alpha1.api.VulnerabilityType_Version_VersionKind" json:"kind,omitempty"`
}

func (m *VulnerabilityType_Version) Reset()                    { *m = VulnerabilityType_Version{} }
func (m *VulnerabilityType_Version) String() string            { return proto.CompactTextString(m) }
func (*VulnerabilityType_Version) ProtoMessage()               {}
func (*VulnerabilityType_Version) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38, 0} }

func (m *VulnerabilityType_Version) GetEpoch() int32 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *VulnerabilityType_Version) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VulnerabilityType_Version) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

func (m *VulnerabilityType_Version) GetKind() VulnerabilityType_Version_VersionKind {
	if m != nil {
		return m.Kind
	}
	return VulnerabilityType_Version_NORMAL
}

// Identifies all occurences of this vulnerability in the package for a
// specific distro/location
// For example: glibc in cpe:/o:debian:debian_linux:8 for versions 2.1 - 2.2
type VulnerabilityType_Detail struct {
	// The cpe_uri in [cpe format] (https://cpe.mitre.org/specification/) in
	// which the vulnerability manifests.  Examples include distro or storage
	// location for vulnerable jar.
	// This field can be used as a filter in list requests.
	CpeUri string `protobuf:"bytes,1,opt,name=cpe_uri,json=cpeUri" json:"cpe_uri,omitempty"`
	// The name of the package where the vulnerability was found.
	// This field can be used as a filter in list requests.
	Package string `protobuf:"bytes,8,opt,name=package" json:"package,omitempty"`
	// The min version of the package in which the vulnerability exists.
	MinAffectedVersion *VulnerabilityType_Version `protobuf:"bytes,6,opt,name=min_affected_version,json=minAffectedVersion" json:"min_affected_version,omitempty"`
	// The max version of the package in which the vulnerability exists.
	// This field can be used as a filter in list requests.
	MaxAffectedVersion *VulnerabilityType_Version `protobuf:"bytes,7,opt,name=max_affected_version,json=maxAffectedVersion" json:"max_affected_version,omitempty"`
	// The severity (eg: distro assigned severity) for this vulnerability.
	SeverityName string `protobuf:"bytes,4,opt,name=severity_name,json=severityName" json:"severity_name,omitempty"`
	// A vendor-specific description of this note.
	Description string `protobuf:"bytes,9,opt,name=description" json:"description,omitempty"`
	// The fix for this specific package version.
	FixedLocation *VulnerabilityType_VulnerabilityLocation `protobuf:"bytes,5,opt,name=fixed_location,json=fixedLocation" json:"fixed_location,omitempty"`
	// The type of package; whether native or non native(ruby gems,
	// node.js packages etc)
	PackageType string `protobuf:"bytes,10,opt,name=package_type,json=packageType" json:"package_type,omitempty"`
}

func (m *VulnerabilityType_Detail) Reset()                    { *m = VulnerabilityType_Detail{} }
func (m *VulnerabilityType_Detail) String() string            { return proto.CompactTextString(m) }
func (*VulnerabilityType_Detail) ProtoMessage()               {}
func (*VulnerabilityType_Detail) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38, 1} }

func (m *VulnerabilityType_Detail) GetCpeUri() string {
	if m != nil {
		return m.CpeUri
	}
	return ""
}

func (m *VulnerabilityType_Detail) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *VulnerabilityType_Detail) GetMinAffectedVersion() *VulnerabilityType_Version {
	if m != nil {
		return m.MinAffectedVersion
	}
	return nil
}

func (m *VulnerabilityType_Detail) GetMaxAffectedVersion() *VulnerabilityType_Version {
	if m != nil {
		return m.MaxAffectedVersion
	}
	return nil
}

func (m *VulnerabilityType_Detail) GetSeverityName() string {
	if m != nil {
		return m.SeverityName
	}
	return ""
}

func (m *VulnerabilityType_Detail) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *VulnerabilityType_Detail) GetFixedLocation() *VulnerabilityType_VulnerabilityLocation {
	if m != nil {
		return m.FixedLocation
	}
	return nil
}

func (m *VulnerabilityType_Detail) GetPackageType() string {
	if m != nil {
		return m.PackageType
	}
	return ""
}

// Used by Occurrence to point to where the vulnerability exists and how
// to fix it.
type VulnerabilityType_VulnerabilityDetails struct {
	// The type of package; whether native or non native(ruby gems,
	// node.js packages etc)
	Type string `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	// The note provider assigned Severity of the vulnerability.
	// @OutputOnly
	Severity VulnerabilityType_Severity `protobuf:"varint,4,opt,name=severity,enum=grafeas.v1alpha1.api.VulnerabilityType_Severity" json:"severity,omitempty"`
	// The CVSS score of this vulnerability. CVSS score is on a scale of 0-10
	// where 0 indicates low severity and 10 indicates high severity.
	// @OutputOnly
	CvssScore float32 `protobuf:"fixed32,5,opt,name=cvss_score,json=cvssScore" json:"cvss_score,omitempty"`
	// The set of affected locations and their fixes (if available) within
	// the associated resource.
	PackageIssue []*VulnerabilityType_PackageIssue `protobuf:"bytes,6,rep,name=package_issue,json=packageIssue" json:"package_issue,omitempty"`
}

func (m *VulnerabilityType_VulnerabilityDetails) Reset() {
	*m = VulnerabilityType_VulnerabilityDetails{}
}
func (m *VulnerabilityType_VulnerabilityDetails) String() string { return proto.CompactTextString(m) }
func (*VulnerabilityType_VulnerabilityDetails) ProtoMessage()    {}
func (*VulnerabilityType_VulnerabilityDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{38, 2}
}

func (m *VulnerabilityType_VulnerabilityDetails) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *VulnerabilityType_VulnerabilityDetails) GetSeverity() VulnerabilityType_Severity {
	if m != nil {
		return m.Severity
	}
	return VulnerabilityType_SEVERITY_UNSPECIFIED
}

func (m *VulnerabilityType_VulnerabilityDetails) GetCvssScore() float32 {
	if m != nil {
		return m.CvssScore
	}
	return 0
}

func (m *VulnerabilityType_VulnerabilityDetails) GetPackageIssue() []*VulnerabilityType_PackageIssue {
	if m != nil {
		return m.PackageIssue
	}
	return nil
}

// This message wraps a location affected by a vulnerability and its
// associated fix (if one is available).
type VulnerabilityType_PackageIssue struct {
	// The location of the vulnerability.
	AffectedLocation *VulnerabilityType_VulnerabilityLocation `protobuf:"bytes,1,opt,name=affected_location,json=affectedLocation" json:"affected_location,omitempty"`
	// The location of the available fix for vulnerability.
	FixedLocation *VulnerabilityType_VulnerabilityLocation `protobuf:"bytes,2,opt,name=fixed_location,json=fixedLocation" json:"fixed_location,omitempty"`
	// The severity (eg: distro assigned severity) for this vulnerability.
	SeverityName string `protobuf:"bytes,3,opt,name=severity_name,json=severityName" json:"severity_name,omitempty"`
}

func (m *VulnerabilityType_PackageIssue) Reset()         { *m = VulnerabilityType_PackageIssue{} }
func (m *VulnerabilityType_PackageIssue) String() string { return proto.CompactTextString(m) }
func (*VulnerabilityType_PackageIssue) ProtoMessage()    {}
func (*VulnerabilityType_PackageIssue) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{38, 3}
}

func (m *VulnerabilityType_PackageIssue) GetAffectedLocation() *VulnerabilityType_VulnerabilityLocation {
	if m != nil {
		return m.AffectedLocation
	}
	return nil
}

func (m *VulnerabilityType_PackageIssue) GetFixedLocation() *VulnerabilityType_VulnerabilityLocation {
	if m != nil {
		return m.FixedLocation
	}
	return nil
}

func (m *VulnerabilityType_PackageIssue) GetSeverityName() string {
	if m != nil {
		return m.SeverityName
	}
	return ""
}

// The location of the vulnerability
type VulnerabilityType_VulnerabilityLocation struct {
	// The cpe_uri in [cpe format] (https://cpe.mitre.org/specification/)
	// format. Examples include distro or storage location for vulnerable jar.
	// This field can be used as a filter in list requests.
	CpeUri string `protobuf:"bytes,1,opt,name=cpe_uri,json=cpeUri" json:"cpe_uri,omitempty"`
	// The package being described.
	Package string `protobuf:"bytes,2,opt,name=package" json:"package,omitempty"`
	// The version of the package being described.
	// This field can be used as a filter in list requests.
	Version *VulnerabilityType_Version `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
}

func (m *VulnerabilityType_VulnerabilityLocation) Reset() {
	*m = VulnerabilityType_VulnerabilityLocation{}
}
func (m *VulnerabilityType_VulnerabilityLocation) String() string { return proto.CompactTextString(m) }
func (*VulnerabilityType_VulnerabilityLocation) ProtoMessage()    {}
func (*VulnerabilityType_VulnerabilityLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{38, 4}
}

func (m *VulnerabilityType_VulnerabilityLocation) GetCpeUri() string {
	if m != nil {
		return m.CpeUri
	}
	return ""
}

func (m *VulnerabilityType_VulnerabilityLocation) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *VulnerabilityType_VulnerabilityLocation) GetVersion() *VulnerabilityType_Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func init() {
	proto.RegisterType((*GetOccurrenceRequest)(nil), "grafeas.v1alpha1.api.GetOccurrenceRequest")
	proto.RegisterType((*ListOccurrencesRequest)(nil), "grafeas.v1alpha1.api.ListOccurrencesRequest")
	proto.RegisterType((*DeleteOccurrenceRequest)(nil), "grafeas.v1alpha1.api.DeleteOccurrenceRequest")
	proto.RegisterType((*CreateOccurrenceRequest)(nil), "grafeas.v1alpha1.api.CreateOccurrenceRequest")
	proto.RegisterType((*UpdateOccurrenceRequest)(nil), "grafeas.v1alpha1.api.UpdateOccurrenceRequest")
	proto.RegisterType((*GetNoteRequest)(nil), "grafeas.v1alpha1.api.GetNoteRequest")
	proto.RegisterType((*GetOccurrenceNoteRequest)(nil), "grafeas.v1alpha1.api.GetOccurrenceNoteRequest")
	proto.RegisterType((*ListNotesRequest)(nil), "grafeas.v1alpha1.api.ListNotesRequest")
	proto.RegisterType((*DeleteNoteRequest)(nil), "grafeas.v1alpha1.api.DeleteNoteRequest")
	proto.RegisterType((*CreateNoteRequest)(nil), "grafeas.v1alpha1.api.CreateNoteRequest")
	proto.RegisterType((*UpdateNoteRequest)(nil), "grafeas.v1alpha1.api.UpdateNoteRequest")
	proto.RegisterType((*ListNoteOccurrencesRequest)(nil), "grafeas.v1alpha1.api.ListNoteOccurrencesRequest")
	proto.RegisterType((*ListNoteOccurrencesResponse)(nil), "grafeas.v1alpha1.api.ListNoteOccurrencesResponse")
	proto.RegisterType((*ListNotesResponse)(nil), "grafeas.v1alpha1.api.ListNotesResponse")
	proto.RegisterType((*ListOccurrencesResponse)(nil), "grafeas.v1alpha1.api.ListOccurrencesResponse")
	proto.RegisterType((*ListOperationsResponse)(nil), "grafeas.v1alpha1.api.ListOperationsResponse")
	proto.RegisterType((*UpdateOperationRequest)(nil), "grafeas.v1alpha1.api.UpdateOperationRequest")
	proto.RegisterType((*CreateOperationRequest)(nil), "grafeas.v1alpha1.api.CreateOperationRequest")
	proto.RegisterType((*OperationMetadata)(nil), "grafeas.v1alpha1.api.OperationMetadata")
	proto.RegisterType((*Artifact)(nil), "grafeas.v1alpha1.api.Artifact")
	proto.RegisterType((*AttestationAuthority)(nil), "grafeas.v1alpha1.api.AttestationAuthority")
	proto.RegisterType((*AttestationAuthority_AttestationAuthorityHint)(nil), "grafeas.v1alpha1.api.AttestationAuthority.AttestationAuthorityHint")
	proto.RegisterType((*AttestationAuthority_Attestation)(nil), "grafeas.v1alpha1.api.AttestationAuthority.Attestation")
	proto.RegisterType((*BuildDetails)(nil), "grafeas.v1alpha1.api.BuildDetails")
	proto.RegisterType((*BuildProvenance)(nil), "grafeas.v1alpha1.api.BuildProvenance")
	proto.RegisterType((*BuildSignature)(nil), "grafeas.v1alpha1.api.BuildSignature")
	proto.RegisterType((*BuildType)(nil), "grafeas.v1alpha1.api.BuildType")
	proto.RegisterType((*Command)(nil), "grafeas.v1alpha1.api.Command")
	proto.RegisterType((*Deployable)(nil), "grafeas.v1alpha1.api.Deployable")
	proto.RegisterType((*Deployable_Deployment)(nil), "grafeas.v1alpha1.api.Deployable.Deployment")
	proto.RegisterType((*DockerImage)(nil), "grafeas.v1alpha1.api.DockerImage")
	proto.RegisterType((*DockerImage_Layer)(nil), "grafeas.v1alpha1.api.DockerImage.Layer")
	proto.RegisterType((*DockerImage_Fingerprint)(nil), "grafeas.v1alpha1.api.DockerImage.Fingerprint")
	proto.RegisterType((*DockerImage_Basis)(nil), "grafeas.v1alpha1.api.DockerImage.Basis")
	proto.RegisterType((*DockerImage_Derived)(nil), "grafeas.v1alpha1.api.DockerImage.Derived")
	proto.RegisterType((*Discovery)(nil), "grafeas.v1alpha1.api.Discovery")
	proto.RegisterType((*Discovery_Discovered)(nil), "grafeas.v1alpha1.api.Discovery.Discovered")
	proto.RegisterType((*FileHashes)(nil), "grafeas.v1alpha1.api.FileHashes")
	proto.RegisterType((*Hash)(nil), "grafeas.v1alpha1.api.Hash")
	proto.RegisterType((*Note)(nil), "grafeas.v1alpha1.api.Note")
	proto.RegisterType((*Note_RelatedUrl)(nil), "grafeas.v1alpha1.api.Note.RelatedUrl")
	proto.RegisterType((*Occurrence)(nil), "grafeas.v1alpha1.api.Occurrence")
	proto.RegisterType((*PackageManager)(nil), "grafeas.v1alpha1.api.PackageManager")
	proto.RegisterType((*PackageManager_Package)(nil), "grafeas.v1alpha1.api.PackageManager.Package")
	proto.RegisterType((*PackageManager_Distribution)(nil), "grafeas.v1alpha1.api.PackageManager.Distribution")
	proto.RegisterType((*PackageManager_Version)(nil), "grafeas.v1alpha1.api.PackageManager.Version")
	proto.RegisterType((*PackageManager_Location)(nil), "grafeas.v1alpha1.api.PackageManager.Location")
	proto.RegisterType((*PackageManager_Installation)(nil), "grafeas.v1alpha1.api.PackageManager.Installation")
	proto.RegisterType((*PgpSignedAttestation)(nil), "grafeas.v1alpha1.api.PgpSignedAttestation")
	proto.RegisterType((*Source)(nil), "grafeas.v1alpha1.api.Source")
	proto.RegisterType((*RepoSource)(nil), "grafeas.v1alpha1.api.RepoSource")
	proto.RegisterType((*StorageSource)(nil), "grafeas.v1alpha1.api.StorageSource")
	proto.RegisterType((*VulnerabilityType)(nil), "grafeas.v1alpha1.api.VulnerabilityType")
	proto.RegisterType((*VulnerabilityType_Version)(nil), "grafeas.v1alpha1.api.VulnerabilityType.Version")
	proto.RegisterType((*VulnerabilityType_Detail)(nil), "grafeas.v1alpha1.api.VulnerabilityType.Detail")
	proto.RegisterType((*VulnerabilityType_VulnerabilityDetails)(nil), "grafeas.v1alpha1.api.VulnerabilityType.VulnerabilityDetails")
	proto.RegisterType((*VulnerabilityType_PackageIssue)(nil), "grafeas.v1alpha1.api.VulnerabilityType.PackageIssue")
	proto.RegisterType((*VulnerabilityType_VulnerabilityLocation)(nil), "grafeas.v1alpha1.api.VulnerabilityType.VulnerabilityLocation")
	proto.RegisterEnum("grafeas.v1alpha1.api.BuildSignature_KeyType", BuildSignature_KeyType_name, BuildSignature_KeyType_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.DockerImage_Layer_Directive", DockerImage_Layer_Directive_name, DockerImage_Layer_Directive_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.Hash_Type", Hash_Type_name, Hash_Type_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.Note_Kind", Note_Kind_name, Note_Kind_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.PackageManager_Distribution_Architecture", PackageManager_Distribution_Architecture_name, PackageManager_Distribution_Architecture_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.PackageManager_Version_VersionKind", PackageManager_Version_VersionKind_name, PackageManager_Version_VersionKind_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.PgpSignedAttestation_ContentType", PgpSignedAttestation_ContentType_name, PgpSignedAttestation_ContentType_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.VulnerabilityType_Severity", VulnerabilityType_Severity_name, VulnerabilityType_Severity_value)
	proto.RegisterEnum("grafeas.v1alpha1.api.VulnerabilityType_Version_VersionKind", VulnerabilityType_Version_VersionKind_name, VulnerabilityType_Version_VersionKind_value)
}

func init() { proto.RegisterFile("v1alpha1/proto/grafeas.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 4149 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x3a, 0x4d, 0x73, 0x23, 0x49,
	0x56, 0x2e, 0x59, 0xb6, 0xa4, 0x27, 0xd9, 0x2e, 0x67, 0xbb, 0xbb, 0xb5, 0xea, 0x9e, 0xed, 0xde,
	0xea, 0x69, 0xba, 0xa7, 0x67, 0x5b, 0x1e, 0xbb, 0x67, 0x7a, 0xbe, 0x18, 0x76, 0xf5, 0xd5, 0x56,
	0xad, 0xf5, 0x15, 0x25, 0xb9, 0x3f, 0x16, 0x82, 0x8a, 0x92, 0x2a, 0x2d, 0xd7, 0x5a, 0xaa, 0x12,
	0x55, 0x25, 0x61, 0xcf, 0xc6, 0x10, 0xc4, 0xee, 0x10, 0x0b, 0x11, 0x1c, 0x36, 0xd8, 0x20, 0xe0,
	0xc0, 0x05, 0x0e, 0x1c, 0xb8, 0x6e, 0xec, 0x81, 0xe0, 0x07, 0x10, 0x1c, 0x81, 0xe0, 0xc8, 0x09,
	0x88, 0x20, 0x80, 0x13, 0x7f, 0x00, 0x22, 0x3f, 0xea, 0x43, 0x72, 0x49, 0x96, 0xbb, 0x7b, 0xf7,
	0xa4, 0xca, 0x97, 0xef, 0xbd, 0x7c, 0x99, 0xf9, 0xbe, 0xf2, 0xe9, 0xc1, 0xed, 0xc9, 0x9e, 0x36,
	0x18, 0x9d, 0x68, 0x7b, 0xbb, 0x23, 0xdb, 0x72, 0xad, 0xdd, 0xbe, 0xad, 0x1d, 0x63, 0xcd, 0xc9,
	0xd3, 0x11, 0xda, 0xf1, 0x86, 0x1e, 0x56, 0x5e, 0x1b, 0x19, 0xb9, 0x5b, 0x7d, 0xcb, 0xea, 0x0f,
	0x30, 0xa3, 0xe8, 0x8e, 0x8f, 0x77, 0xf1, 0x70, 0xe4, 0x9e, 0x33, 0x92, 0xdc, 0x6d, 0x3e, 0xa9,
	0x8d, 0x8c, 0x5d, 0xcd, 0x34, 0x2d, 0x57, 0x73, 0x0d, 0xcb, 0xe4, 0x0c, 0x73, 0x77, 0x66, 0x49,
	0x5d, 0x63, 0x88, 0x1d, 0x57, 0x1b, 0x8e, 0x38, 0xc2, 0x3d, 0x8e, 0x30, 0xb0, 0xcc, 0xbe, 0x3d,
	0x36, 0x4d, 0xc3, 0xec, 0xef, 0x5a, 0x23, 0x6c, 0x4f, 0x71, 0xc9, 0x73, 0x24, 0x1d, 0x4f, 0x5c,
	0xcb, 0x1a, 0x38, 0xbb, 0x8e, 0x35, 0xb6, 0x7b, 0x78, 0x77, 0xb2, 0xc7, 0xbf, 0xd4, 0x9e, 0x65,
	0xba, 0xf8, 0xcc, 0x65, 0xf8, 0xd2, 0x23, 0xd8, 0x39, 0xc0, 0x6e, 0xb3, 0xd7, 0x1b, 0xdb, 0x36,
	0x36, 0x7b, 0x58, 0xc1, 0xbf, 0x33, 0xc6, 0x8e, 0x8b, 0x10, 0xc4, 0x4d, 0x6d, 0x88, 0xb3, 0xc2,
	0x5d, 0xe1, 0x61, 0x4a, 0xa1, 0xdf, 0xd2, 0xd7, 0x02, 0xdc, 0xa8, 0x19, 0x4e, 0x08, 0xdb, 0xf1,
	0xd0, 0x6f, 0xc0, 0xfa, 0x48, 0xb3, 0xb1, 0xe9, 0x66, 0xd7, 0x28, 0x01, 0x1f, 0x11, 0xf8, 0xb1,
	0x31, 0x70, 0xb1, 0x9d, 0x8d, 0x31, 0x38, 0x1b, 0xa1, 0x5b, 0x90, 0x1a, 0x69, 0x7d, 0xac, 0x3a,
	0xc6, 0x97, 0x38, 0xbb, 0x7a, 0x57, 0x78, 0xb8, 0xa6, 0x24, 0x09, 0xa0, 0x6d, 0x7c, 0x89, 0xd1,
	0x3b, 0x00, 0x74, 0xd2, 0xb5, 0x4e, 0xb1, 0x99, 0x8d, 0x53, 0x42, 0x8a, 0xde, 0x21, 0x00, 0xe9,
	0x31, 0xdc, 0x2c, 0xe3, 0x01, 0x76, 0xf1, 0x72, 0x52, 0x3b, 0x70, 0xb3, 0x64, 0x63, 0x2d, 0x0a,
	0x3d, 0x90, 0x7a, 0x75, 0x4a, 0xea, 0xef, 0x02, 0x58, 0x3e, 0x32, 0x95, 0x3c, 0xbd, 0x7f, 0x37,
	0x1f, 0x75, 0xe1, 0xf9, 0x10, 0xd3, 0x10, 0x8d, 0x64, 0xc1, 0xcd, 0xa3, 0x91, 0xae, 0x2d, 0x29,
	0xe3, 0x5b, 0x58, 0xf0, 0x5d, 0xd8, 0x3c, 0xc0, 0x6e, 0xc3, 0x72, 0x17, 0x9e, 0x45, 0x1e, 0xb2,
	0x53, 0xb7, 0x7d, 0x19, 0xfe, 0x9f, 0x08, 0x20, 0x92, 0x1b, 0x27, 0x78, 0xce, 0xa2, 0x0d, 0xfc,
	0x2a, 0xef, 0xff, 0x01, 0x6c, 0xb3, 0xfb, 0xbf, 0x4c, 0xfa, 0x3f, 0x14, 0x60, 0x9b, 0x5d, 0xfd,
	0x25, 0x98, 0x21, 0xf1, 0xe3, 0x53, 0xe2, 0xdf, 0x84, 0x84, 0x69, 0xb9, 0x58, 0x35, 0x74, 0x4f,
	0x7e, 0x32, 0x94, 0x75, 0x94, 0x87, 0x38, 0xf9, 0xa2, 0xa2, 0xa7, 0xf7, 0x73, 0xd1, 0x57, 0x45,
	0x57, 0xa5, 0x78, 0xd2, 0x0b, 0xd8, 0x66, 0xfa, 0x70, 0x99, 0x24, 0x1e, 0xe3, 0xd8, 0x92, 0x8c,
	0xbf, 0x16, 0x20, 0xe7, 0xdd, 0x50, 0x84, 0x5d, 0xce, 0xd9, 0xec, 0x5b, 0xbf, 0x93, 0x9f, 0x08,
	0x70, 0x2b, 0x52, 0x0c, 0x67, 0x64, 0x99, 0x0e, 0x46, 0xef, 0xc2, 0x86, 0x89, 0xcf, 0xdc, 0x96,
	0x47, 0xc0, 0x05, 0x9a, 0x06, 0xa2, 0x22, 0xa4, 0x03, 0x95, 0x76, 0xb2, 0xb1, 0xbb, 0xab, 0x4b,
	0xd9, 0x41, 0x98, 0x48, 0x3a, 0x85, 0xed, 0x90, 0xc6, 0x5e, 0x69, 0xf9, 0x0f, 0x60, 0x8d, 0x9c,
	0xa9, 0xb7, 0xf0, 0xa2, 0xc3, 0x67, 0x88, 0xd2, 0x8f, 0x05, 0xb8, 0x79, 0xc1, 0x23, 0xfe, 0xca,
	0xb7, 0xfc, 0x15, 0x77, 0xcb, 0x7e, 0x2c, 0xb8, 0xa2, 0x0c, 0x5f, 0x00, 0x04, 0x71, 0x84, 0x8b,
	0xf0, 0x0e, 0x0f, 0x24, 0xf9, 0x50, 0xb4, 0xc9, 0xfb, 0x2b, 0x28, 0x21, 0x02, 0xc9, 0x80, 0x1b,
	0xdc, 0xd7, 0xf9, 0xd3, 0x0b, 0xb4, 0xef, 0x73, 0x48, 0xf9, 0xb4, 0xdc, 0x7c, 0x2e, 0x59, 0x2b,
	0xc0, 0x97, 0x7e, 0x2a, 0xc0, 0x0d, 0xee, 0xcc, 0x67, 0xd7, 0x0a, 0x4c, 0x58, 0x98, 0x32, 0xe1,
	0x6f, 0x41, 0xc6, 0xa7, 0x0f, 0xec, 0x38, 0xed, 0xc3, 0x64, 0xfd, 0xcd, 0x44, 0xfa, 0x89, 0x00,
	0xdb, 0xfe, 0x44, 0x1d, 0xbb, 0x9a, 0xae, 0xb9, 0x1a, 0xfa, 0x1c, 0xd2, 0x3d, 0x2a, 0xa7, 0x4a,
	0xa2, 0x38, 0x15, 0x89, 0x2a, 0x14, 0x63, 0xea, 0x85, 0xf8, 0x7c, 0xc7, 0x0b, 0xf1, 0x0a, 0x30,
	0x74, 0x02, 0x40, 0x1f, 0x41, 0x12, 0x9b, 0x3a, 0xa3, 0x8c, 0x5d, 0x4a, 0x99, 0xc0, 0xa6, 0x4e,
	0x46, 0x52, 0x0d, 0x92, 0x05, 0xdb, 0x35, 0x8e, 0xb5, 0x9e, 0x8b, 0x72, 0x90, 0xec, 0x9d, 0xe0,
	0xde, 0xa9, 0x33, 0x1e, 0xf2, 0xf3, 0xf0, 0xc7, 0x68, 0x13, 0x62, 0xfe, 0x39, 0xc4, 0x0c, 0x1d,
	0xed, 0xc0, 0x1a, 0xb9, 0x19, 0x27, 0xbb, 0x7a, 0x77, 0xf5, 0x61, 0x4a, 0x61, 0x03, 0xe9, 0xef,
	0x62, 0xb0, 0x53, 0x70, 0x5d, 0xb2, 0x08, 0xd9, 0x59, 0x61, 0xec, 0x9e, 0x58, 0xb6, 0xe1, 0x9e,
	0xa3, 0x17, 0x10, 0x3f, 0x31, 0xf8, 0x31, 0xa7, 0xf7, 0x4b, 0xd1, 0xaa, 0x1a, 0x45, 0x19, 0x09,
	0xac, 0x1a, 0xa6, 0xab, 0x50, 0x86, 0xb9, 0xef, 0x41, 0x76, 0x1e, 0x06, 0xca, 0xc3, 0xb5, 0x93,
	0xf1, 0x50, 0x33, 0x55, 0x1b, 0x6b, 0xba, 0xd6, 0x1d, 0x60, 0x35, 0xa4, 0x58, 0xdb, 0x74, 0x4a,
	0xe1, 0x33, 0x0d, 0x6d, 0x88, 0x73, 0xbf, 0x07, 0xe9, 0x10, 0x2f, 0xd4, 0x85, 0x1b, 0xa3, 0xfe,
	0x48, 0x75, 0x8c, 0xbe, 0x89, 0x75, 0x55, 0x0b, 0x66, 0xf8, 0x2e, 0x1e, 0x45, 0xef, 0xa2, 0xd5,
	0x1f, 0xb5, 0x29, 0x49, 0x88, 0x57, 0x75, 0x45, 0xd9, 0x19, 0x45, 0xc0, 0x8b, 0x69, 0x48, 0x11,
	0xfe, 0x9a, 0x3b, 0xb6, 0xb1, 0xf4, 0xfb, 0x02, 0x64, 0x8a, 0x63, 0x63, 0xa0, 0x97, 0xb1, 0xab,
	0x19, 0x03, 0x07, 0x55, 0x00, 0x46, 0xb6, 0x35, 0xc1, 0xa6, 0x46, 0x22, 0x3c, 0x5b, 0xf5, 0x7e,
	0xf4, 0xaa, 0x94, 0xae, 0xe5, 0x23, 0x2b, 0x21, 0x42, 0xf4, 0x1e, 0x88, 0xc1, 0x48, 0xed, 0x9e,
	0x33, 0x6f, 0x45, 0x0e, 0x61, 0x2b, 0x80, 0x17, 0x09, 0x58, 0xfa, 0xf9, 0x1a, 0x6c, 0xcd, 0xb0,
	0x42, 0xbf, 0x05, 0x1b, 0x5d, 0x02, 0x52, 0xad, 0x11, 0x33, 0x76, 0x81, 0x1a, 0xfb, 0xc7, 0x4b,
	0x09, 0xc2, 0xc6, 0x4d, 0x46, 0x59, 0x31, 0x5d, 0xfb, 0x5c, 0xc9, 0x74, 0x43, 0x20, 0xf4, 0x00,
	0xb6, 0xe8, 0x18, 0xdb, 0xea, 0x04, 0xdb, 0x0e, 0x39, 0x5e, 0x26, 0xdb, 0x26, 0x07, 0x3f, 0x67,
	0x50, 0x74, 0xc0, 0x10, 0x5d, 0x55, 0xe3, 0xfa, 0xca, 0x74, 0x2f, 0xbd, 0xff, 0xcd, 0x39, 0xda,
	0xc4, 0xd1, 0x18, 0x23, 0xd7, 0x1b, 0x3a, 0xe8, 0x53, 0x48, 0xf6, 0xac, 0xe1, 0x50, 0x33, 0x75,
	0x27, 0x1b, 0xf7, 0xfc, 0x56, 0x14, 0x87, 0x12, 0xc3, 0x52, 0x7c, 0x74, 0x74, 0x67, 0xda, 0x42,
	0x59, 0xda, 0x12, 0xb6, 0xc2, 0x2c, 0x24, 0xe8, 0xc8, 0xb2, 0xb3, 0xeb, 0x74, 0xd2, 0x1b, 0x12,
	0xd2, 0x63, 0xc3, 0x34, 0x9c, 0x13, 0x46, 0x9a, 0x60, 0xa4, 0x0c, 0x44, 0x49, 0x99, 0x85, 0x25,
	0x7d, 0x0b, 0xbb, 0x03, 0xe9, 0x81, 0xd5, 0x77, 0xd4, 0xee, 0xb8, 0x77, 0x8a, 0xdd, 0x6c, 0x8a,
	0x11, 0x10, 0x50, 0x91, 0x42, 0x68, 0x74, 0xb5, 0xad, 0x1f, 0xe0, 0x9e, 0x4b, 0x5c, 0x14, 0xf0,
	0xe8, 0xca, 0x20, 0x32, 0xa5, 0xf7, 0xa6, 0xcd, 0xf1, 0x30, 0x9b, 0x66, 0xf4, 0x1c, 0xd4, 0x18,
	0x0f, 0x91, 0x0c, 0xdb, 0x3c, 0xbb, 0x0f, 0x29, 0x59, 0x86, 0x2a, 0xd9, 0xed, 0xe8, 0x03, 0x69,
	0x53, 0x74, 0x45, 0x64, 0x64, 0x21, 0x15, 0x79, 0x07, 0xc0, 0x71, 0x35, 0xdb, 0x65, 0x7b, 0xdb,
	0x60, 0xa2, 0x50, 0x08, 0xdd, 0xda, 0x3b, 0x00, 0xae, 0x6d, 0xf4, 0xfb, 0xd8, 0x26, 0x92, 0x6e,
	0xb2, 0x69, 0x0e, 0x91, 0xf5, 0xdc, 0x77, 0x60, 0xfb, 0x82, 0x96, 0x20, 0x11, 0x56, 0x4f, 0xf1,
	0x39, 0x37, 0x56, 0xf2, 0x49, 0x5c, 0xce, 0x44, 0x1b, 0x8c, 0x31, 0xd7, 0x0f, 0x36, 0xf8, 0x2c,
	0xf6, 0x89, 0x20, 0xfd, 0xa7, 0x00, 0x9b, 0x94, 0x43, 0xdb, 0xb3, 0x25, 0x74, 0x1d, 0xd6, 0x4f,
	0xf1, 0x39, 0x59, 0x8e, 0x71, 0x58, 0x3b, 0xc5, 0xe7, 0xb2, 0x8e, 0x0e, 0x20, 0x49, 0xc0, 0xee,
	0xf9, 0x88, 0xb1, 0xd9, 0xdc, 0xff, 0xf6, 0x02, 0x35, 0xf6, 0xd9, 0xe5, 0x0f, 0xf1, 0x79, 0xe7,
	0x7c, 0x84, 0x95, 0xc4, 0x29, 0xfb, 0xa0, 0x87, 0x3f, 0xee, 0x0e, 0x8c, 0x9e, 0x4a, 0xa4, 0x5c,
	0xe5, 0x87, 0x4f, 0x21, 0x87, 0xf8, 0x1c, 0xdd, 0x0e, 0xd9, 0xb5, 0x97, 0xf8, 0x04, 0x86, 0xfe,
	0x29, 0x24, 0x38, 0x43, 0x94, 0x82, 0xb5, 0xa3, 0x46, 0xbb, 0xd2, 0x11, 0x57, 0xd0, 0x75, 0xd8,
	0x6e, 0x1d, 0xb4, 0xd4, 0x42, 0xbb, 0x24, 0xcb, 0x6a, 0x41, 0xa9, 0x37, 0x95, 0x4a, 0x59, 0x14,
	0x50, 0x06, 0x92, 0xad, 0x43, 0xf9, 0xa5, 0xda, 0xaa, 0xd4, 0xc5, 0x98, 0x74, 0x06, 0x29, 0x2a,
	0x1a, 0x25, 0x8e, 0xb0, 0x1d, 0x21, 0xd2, 0x76, 0x8a, 0x61, 0x71, 0x58, 0x74, 0x78, 0x77, 0x99,
	0x7d, 0x2b, 0xd3, 0xde, 0x29, 0xc1, 0x2d, 0x82, 0xc4, 0x68, 0xcd, 0xee, 0x33, 0x4f, 0x90, 0x52,
	0xe8, 0x37, 0xb9, 0x30, 0xdd, 0xf0, 0xd2, 0x43, 0xf2, 0x49, 0x20, 0xd8, 0x9c, 0xf0, 0x08, 0x41,
	0x3e, 0xb9, 0x8e, 0xc7, 0x7d, 0x1d, 0xf7, 0x62, 0xfd, 0x5a, 0x28, 0xd6, 0x7f, 0x03, 0x92, 0xbf,
	0xab, 0x19, 0xae, 0x7a, 0x4c, 0x6d, 0x88, 0x90, 0x26, 0xc8, 0xf8, 0x99, 0x65, 0x4b, 0xff, 0x10,
	0x03, 0x28, 0xe3, 0xd1, 0xc0, 0x3a, 0x27, 0x3e, 0x9b, 0x44, 0x69, 0x1b, 0x73, 0x15, 0x1e, 0xdb,
	0x06, 0x97, 0x26, 0xed, 0xc1, 0x8e, 0x6c, 0x23, 0xf7, 0x67, 0x3e, 0xc5, 0x90, 0xc4, 0xf5, 0x2c,
	0x24, 0x34, 0x5d, 0xb7, 0xb1, 0xe3, 0xf0, 0x83, 0xf2, 0x86, 0xa8, 0x09, 0xeb, 0x3d, 0xcb, 0x3c,
	0x36, 0xfa, 0x3c, 0x95, 0x99, 0xe3, 0xdd, 0x82, 0xd5, 0xf3, 0x01, 0xdb, 0x7c, 0x89, 0x52, 0x32,
	0xef, 0xc6, 0xd9, 0x10, 0xf3, 0xd3, 0x29, 0x06, 0xb3, 0x09, 0xa6, 0x21, 0xc0, 0x40, 0xd4, 0x28,
	0xee, 0xc1, 0xc6, 0xd8, 0x0c, 0xa3, 0xb0, 0x63, 0xc9, 0x78, 0x40, 0xcf, 0x72, 0xc6, 0x0e, 0xb6,
	0x55, 0x3c, 0xd4, 0x8c, 0x01, 0x3f, 0xa6, 0x14, 0x81, 0x54, 0x08, 0x20, 0xf7, 0x29, 0xa4, 0x43,
	0x6b, 0x5f, 0xc9, 0x66, 0xfe, 0x76, 0x1d, 0xd2, 0x65, 0xab, 0x77, 0x8a, 0x6d, 0x79, 0xa8, 0xf5,
	0x71, 0xee, 0x3f, 0x62, 0xb0, 0x56, 0xd3, 0xce, 0xb1, 0x4d, 0x74, 0x57, 0xb3, 0xfb, 0x63, 0xb2,
	0x33, 0xef, 0x98, 0x02, 0x00, 0x6a, 0x42, 0x4a, 0x37, 0x6c, 0xdc, 0x73, 0x8d, 0x89, 0x67, 0x42,
	0x7b, 0x73, 0xce, 0x2a, 0xe0, 0x9e, 0xa7, 0x9c, 0xf3, 0x65, 0x8f, 0x50, 0x09, 0x78, 0x48, 0xff,
	0x23, 0x40, 0xca, 0x9f, 0x20, 0x46, 0x70, 0xd4, 0x38, 0x6c, 0x34, 0x5f, 0x34, 0xd4, 0xb2, 0xac,
	0x54, 0x4a, 0x1d, 0xf9, 0x79, 0x45, 0x5c, 0x41, 0x9b, 0x00, 0xf5, 0x82, 0xdc, 0xe8, 0x14, 0xe4,
	0x46, 0x45, 0x11, 0x05, 0x94, 0x80, 0x55, 0xe5, 0xa8, 0x21, 0xc6, 0xc8, 0x47, 0xa9, 0x5e, 0x16,
	0x57, 0x89, 0x21, 0xd5, 0x0a, 0xc5, 0x4a, 0x4d, 0x8c, 0x23, 0x80, 0xf5, 0xca, 0xcb, 0x56, 0xb3,
	0x5d, 0x11, 0xd7, 0xc8, 0x7c, 0xa5, 0xf1, 0x5c, 0x5c, 0x27, 0x1f, 0x85, 0x72, 0x59, 0x4c, 0xa0,
	0x24, 0xc4, 0x4b, 0xcd, 0xd6, 0x2b, 0x31, 0x49, 0x98, 0x56, 0x1a, 0x1d, 0xe5, 0x55, 0xab, 0x29,
	0x37, 0x3a, 0x62, 0x8a, 0xd0, 0x3d, 0x6f, 0xd6, 0x8e, 0xea, 0x15, 0x11, 0x08, 0xd6, 0x51, 0xbb,
	0xa2, 0x88, 0x69, 0x94, 0x86, 0xc4, 0x8b, 0xa6, 0x72, 0x58, 0x96, 0x15, 0x31, 0x43, 0xb9, 0x28,
	0x07, 0xe2, 0x06, 0x81, 0x36, 0x1b, 0xc5, 0x23, 0xb9, 0x56, 0x16, 0x37, 0x09, 0xa3, 0x76, 0xa7,
	0xd9, 0x6a, 0xcb, 0x07, 0x8d, 0x42, 0x4d, 0xdc, 0x42, 0x5b, 0x90, 0xae, 0x56, 0x0a, 0xb5, 0x4e,
	0xb5, 0x54, 0xad, 0x94, 0x0e, 0x45, 0x91, 0x08, 0xd7, 0xae, 0x56, 0x6a, 0x35, 0x71, 0x3b, 0xf7,
	0x12, 0xd2, 0xcf, 0x0c, 0xb3, 0x8f, 0xed, 0x91, 0x6d, 0xb0, 0xc7, 0xe2, 0x64, 0x2f, 0x9c, 0x97,
	0xac, 0x4f, 0xf6, 0x48, 0x32, 0x42, 0x27, 0xf6, 0xd5, 0xee, 0xc0, 0xea, 0x52, 0x8d, 0x24, 0x13,
	0xfb, 0xc5, 0x81, 0xd5, 0xe5, 0x13, 0x94, 0x82, 0x17, 0x20, 0x26, 0xfb, 0x34, 0x7d, 0xf9, 0x21,
	0xac, 0x15, 0x35, 0xc7, 0x20, 0x57, 0x44, 0x42, 0x8d, 0xb7, 0x04, 0xcf, 0x1b, 0x1e, 0x5f, 0x7e,
	0x49, 0x21, 0xb9, 0x94, 0x30, 0x87, 0x19, 0x43, 0x1b, 0x78, 0xe9, 0x70, 0x60, 0x68, 0x83, 0xdc,
	0x7f, 0x09, 0x90, 0x28, 0x63, 0xdb, 0x98, 0x60, 0x1d, 0x3d, 0x82, 0xed, 0xae, 0xe6, 0x60, 0x75,
	0x8a, 0x86, 0xed, 0x6e, 0x8b, 0x4c, 0x28, 0x01, 0x1d, 0xc9, 0x39, 0x75, 0xc3, 0x71, 0x35, 0xaf,
	0x84, 0xb1, 0xa1, 0xf8, 0xe3, 0xd9, 0x7d, 0xac, 0xbe, 0xf1, 0x3e, 0x9e, 0x01, 0x0c, 0x88, 0x22,
	0xaa, 0x86, 0x79, 0x6c, 0xf1, 0xd8, 0xff, 0x60, 0x49, 0xe5, 0x55, 0x52, 0x94, 0x54, 0x36, 0x8f,
	0x2d, 0xe9, 0x2f, 0xa8, 0xca, 0x3a, 0x3d, 0x6b, 0x82, 0xed, 0x73, 0x54, 0x86, 0x0d, 0xcd, 0xd4,
	0x06, 0xe7, 0x8e, 0xe1, 0xa8, 0xa7, 0x86, 0xc9, 0x22, 0xce, 0xe6, 0xfe, 0x9d, 0xf9, 0x2f, 0xc1,
	0xfc, 0xa1, 0x61, 0xea, 0x4a, 0xc6, 0xa3, 0x22, 0xa3, 0x9c, 0x0c, 0xe0, 0xb1, 0xc4, 0x33, 0xaf,
	0x0b, 0xe1, 0x8a, 0xaf, 0x8b, 0x0a, 0xc0, 0x33, 0x63, 0x80, 0xab, 0x9a, 0x73, 0x82, 0x1d, 0xf4,
	0x31, 0xa4, 0x8e, 0x8d, 0x01, 0x56, 0x4f, 0x34, 0xe7, 0x84, 0xa7, 0x6e, 0x73, 0x1e, 0xa9, 0x84,
	0x40, 0x49, 0x1e, 0x73, 0x52, 0xe9, 0x0c, 0xe2, 0xe4, 0x17, 0x3d, 0x81, 0x38, 0x8d, 0x97, 0x0b,
	0xb7, 0x45, 0x30, 0xf3, 0x34, 0x44, 0x52, 0xe4, 0x68, 0xc7, 0x23, 0xdd, 0x87, 0x38, 0x0d, 0x5c,
	0x49, 0x88, 0x37, 0x9a, 0x0d, 0x62, 0xd8, 0x00, 0xeb, 0xed, 0x6a, 0x61, 0xff, 0xa3, 0xa7, 0xcc,
	0xa8, 0xeb, 0xe5, 0x8f, 0xc4, 0x98, 0xf4, 0xaf, 0x29, 0x88, 0x93, 0x73, 0x8a, 0x7c, 0x0b, 0xbe,
	0x0f, 0xdb, 0xce, 0x89, 0x65, 0xbb, 0xaa, 0x8e, 0x9d, 0x9e, 0x6d, 0x8c, 0xfc, 0x07, 0x58, 0x4a,
	0x11, 0xe9, 0x44, 0x39, 0x80, 0x93, 0xd4, 0x97, 0x1c, 0xd7, 0x14, 0x2e, 0xf3, 0xb3, 0x5b, 0x04,
	0x1e, 0x46, 0x7d, 0x02, 0x71, 0x7a, 0x7b, 0xa9, 0xe5, 0x6e, 0x8f, 0x22, 0xa3, 0x97, 0x80, 0x26,
	0xe3, 0x81, 0x89, 0x6d, 0xad, 0x6b, 0x0c, 0x0c, 0x97, 0x67, 0x16, 0xeb, 0xf4, 0xc2, 0xe6, 0x68,
	0xd6, 0xf3, 0x30, 0x3e, 0x39, 0x8d, 0xea, 0x8a, 0xb2, 0x3d, 0x99, 0x05, 0xa2, 0xef, 0x02, 0xb0,
	0xac, 0x9b, 0x72, 0x4c, 0x52, 0x8e, 0x77, 0x16, 0xc4, 0x6c, 0xce, 0x29, 0xd5, 0xf5, 0xb3, 0x83,
	0x2a, 0x00, 0x35, 0x43, 0x83, 0x28, 0x31, 0x4d, 0xca, 0x96, 0xd2, 0x76, 0xea, 0x43, 0x28, 0x27,
	0xcd, 0xc1, 0x14, 0x84, 0xaa, 0x90, 0x18, 0x69, 0xbd, 0x53, 0xc2, 0x66, 0x93, 0xb2, 0x99, 0x93,
	0x34, 0xb5, 0x18, 0x52, 0x5d, 0x33, 0xb5, 0x3e, 0xb6, 0xbd, 0x61, 0x75, 0x45, 0xf1, 0xc8, 0x51,
	0x11, 0x78, 0x08, 0x24, 0x21, 0x34, 0xbb, 0xbd, 0xa8, 0x66, 0x19, 0x84, 0xda, 0xea, 0x8a, 0x12,
	0xa2, 0x42, 0xdf, 0x21, 0x11, 0x88, 0x1b, 0x5f, 0x16, 0x2d, 0x3a, 0x18, 0xdf, 0x46, 0xc9, 0x76,
	0x7c, 0x1a, 0xa4, 0xc1, 0xf5, 0xd0, 0x6b, 0x4e, 0xd5, 0xbc, 0x47, 0x63, 0xf6, 0xda, 0xa2, 0x77,
	0x5d, 0xe4, 0x33, 0x73, 0x45, 0xd9, 0xd1, 0xa2, 0xde, 0xbb, 0xcf, 0x20, 0x6d, 0xe3, 0x81, 0xe6,
	0x62, 0x9d, 0x3a, 0xbf, 0x04, 0x35, 0xbb, 0xfb, 0x0b, 0x74, 0x4a, 0x61, 0xd8, 0x47, 0xf6, 0x40,
	0x01, 0xdb, 0xff, 0x46, 0x25, 0xd8, 0xc2, 0x67, 0x23, 0x83, 0x57, 0x22, 0x68, 0x9a, 0x00, 0x97,
	0x3e, 0xee, 0x37, 0x03, 0x12, 0x9a, 0x44, 0xcc, 0xd4, 0x15, 0xd2, 0x57, 0xaa, 0x2b, 0x7c, 0x0e,
	0xe9, 0x31, 0x2d, 0xd4, 0x30, 0xe2, 0xcc, 0xe5, 0xc4, 0x0c, 0x9d, 0x12, 0xdf, 0x87, 0xcd, 0xa0,
	0x8e, 0x42, 0x2d, 0x79, 0x8b, 0xd5, 0x92, 0x7c, 0x28, 0x8d, 0x5c, 0x1f, 0x02, 0x04, 0xfb, 0x27,
	0x59, 0x4c, 0x10, 0x30, 0xc8, 0x27, 0x71, 0x26, 0x03, 0xad, 0x8b, 0xbd, 0xc0, 0xc3, 0x06, 0xd2,
	0xdf, 0x08, 0x10, 0x27, 0xa6, 0x88, 0x76, 0x40, 0x3c, 0x94, 0x1b, 0x65, 0xf5, 0xa8, 0xd1, 0x6e,
	0x55, 0x4a, 0xf2, 0x33, 0xb9, 0x52, 0x16, 0x57, 0xd0, 0x37, 0xe0, 0x7a, 0xab, 0x50, 0x3a, 0x2c,
	0x1c, 0x54, 0xd4, 0xe7, 0x47, 0xb5, 0x46, 0x45, 0x29, 0x14, 0xe5, 0x9a, 0xdc, 0x79, 0x25, 0x0a,
	0x68, 0x1b, 0x36, 0x68, 0xe8, 0x56, 0xcb, 0x95, 0x4e, 0x41, 0xae, 0xb5, 0xc5, 0x18, 0x09, 0xd9,
	0x72, 0x9d, 0xe0, 0x16, 0x0b, 0x6d, 0xb9, 0x2d, 0xae, 0xa2, 0x6b, 0xb0, 0xe5, 0x91, 0xd7, 0x0b,
	0x8d, 0xc2, 0x41, 0x45, 0x11, 0xe3, 0x24, 0xd0, 0x97, 0x2b, 0xad, 0x5a, 0xf3, 0x55, 0xa1, 0x58,
	0x23, 0xd9, 0xc5, 0x06, 0xa4, 0xca, 0x72, 0xbb, 0xd4, 0x7c, 0x5e, 0x51, 0x5e, 0x89, 0xeb, 0x64,
	0xc9, 0x42, 0xa7, 0x53, 0x69, 0x77, 0x0a, 0x1d, 0xb9, 0xd9, 0x50, 0x0b, 0x47, 0x9d, 0x6a, 0x53,
	0x21, 0x4b, 0x26, 0xc8, 0x43, 0x9f, 0x16, 0x85, 0x89, 0x35, 0x4b, 0x7f, 0x9f, 0x00, 0x08, 0xea,
	0x72, 0x91, 0x5e, 0xee, 0xf2, 0x90, 0x8b, 0x6e, 0x71, 0x96, 0xa1, 0x54, 0x20, 0x49, 0x00, 0x34,
	0x7d, 0xf0, 0xbc, 0xd9, 0xfa, 0x55, 0xbc, 0x99, 0x03, 0xd7, 0xa7, 0xbd, 0x99, 0xce, 0x0a, 0x11,
	0xdc, 0xfd, 0xfc, 0xfa, 0x92, 0x0e, 0x6d, 0x1a, 0xc2, 0x8b, 0x19, 0xc4, 0x54, 0x26, 0x11, 0x70,
	0x24, 0x7b, 0xe5, 0x05, 0x6f, 0xb1, 0x04, 0x5d, 0x4c, 0x5a, 0xe0, 0xeb, 0x02, 0x96, 0xac, 0x96,
	0xe0, 0xb1, 0x6a, 0xc1, 0x86, 0xce, 0x72, 0x10, 0xee, 0xf4, 0x98, 0xaa, 0xbf, 0x77, 0xb9, 0xd3,
	0xe3, 0xa9, 0x0b, 0xe1, 0xc8, 0x39, 0x30, 0xcf, 0xf7, 0x02, 0x32, 0x86, 0xe9, 0xb8, 0xda, 0x60,
	0xc0, 0x42, 0x31, 0x53, 0xff, 0xbd, 0xa5, 0xdc, 0x9f, 0x1c, 0x22, 0x24, 0x8c, 0xc3, 0x8c, 0x50,
	0xdd, 0x73, 0x84, 0x24, 0xab, 0xe6, 0x5e, 0xf5, 0xfd, 0x2b, 0xbc, 0x39, 0x02, 0x9f, 0x48, 0x1f,
	0x36, 0x35, 0x00, 0xdd, 0xcf, 0x1e, 0xa8, 0x91, 0xcd, 0xf5, 0x63, 0xbe, 0x53, 0xcc, 0x07, 0xf9,
	0x06, 0xe5, 0x16, 0x64, 0x1f, 0xdf, 0x87, 0x74, 0xb8, 0xdc, 0x25, 0x52, 0x76, 0x4f, 0x5f, 0xaf,
	0x68, 0x57, 0x5d, 0x51, 0xc2, 0xcc, 0xd0, 0x5d, 0xe2, 0x19, 0x87, 0x58, 0x37, 0x18, 0xef, 0x35,
	0x4f, 0xaf, 0x7d, 0xd0, 0xac, 0xbb, 0x4a, 0xbd, 0x89, 0xbb, 0x82, 0x37, 0x74, 0x57, 0x1b, 0x11,
	0xee, 0xaa, 0x98, 0x82, 0x04, 0xd7, 0x55, 0xe9, 0x17, 0x09, 0xd8, 0x9c, 0xbe, 0xf6, 0x9c, 0x0b,
	0x09, 0x0e, 0x41, 0x47, 0x90, 0x21, 0xc9, 0xac, 0x6d, 0x74, 0xc7, 0x3c, 0x91, 0x5b, 0x5d, 0x5a,
	0x7b, 0xca, 0x21, 0x42, 0x65, 0x8a, 0x8d, 0xef, 0x2f, 0x62, 0x81, 0xbf, 0xc8, 0xfd, 0x5b, 0x0c,
	0x32, 0x61, 0x12, 0xd4, 0x85, 0x8c, 0x66, 0xf7, 0x4e, 0x0c, 0x17, 0xf7, 0xe8, 0xab, 0x9f, 0x65,
	0x6f, 0xbf, 0x71, 0xe5, 0xb5, 0xf3, 0x85, 0x10, 0x17, 0x65, 0x8a, 0x27, 0x79, 0x8a, 0xf4, 0x46,
	0xec, 0xed, 0xcd, 0xff, 0x15, 0xea, 0x8d, 0xc8, 0xb3, 0x9b, 0x5c, 0xf2, 0xc5, 0xec, 0x2c, 0x0c,
	0x42, 0x6d, 0xd8, 0x24, 0x0e, 0xdf, 0x71, 0xfd, 0xca, 0x45, 0xfc, 0x0a, 0x99, 0x05, 0xaf, 0x6b,
	0x28, 0x1b, 0x8c, 0x87, 0x57, 0xe6, 0xf8, 0x26, 0xc0, 0x50, 0x33, 0x4c, 0x57, 0x33, 0x4c, 0x6c,
	0x7b, 0xd5, 0xb9, 0x00, 0xe2, 0x45, 0x96, 0x75, 0x3f, 0xb2, 0x48, 0x8f, 0x21, 0x13, 0xde, 0x1f,
	0x79, 0xd6, 0xf1, 0xe7, 0xa7, 0xb8, 0x42, 0xf2, 0xd1, 0x97, 0x9f, 0xf0, 0xc4, 0xf4, 0xe5, 0xd3,
	0x0f, 0xc5, 0x58, 0xee, 0x9f, 0x04, 0x48, 0x78, 0x8b, 0xed, 0xc0, 0x1a, 0x1e, 0x59, 0xbd, 0x13,
	0x7a, 0xb2, 0x6b, 0x0a, 0x1b, 0x44, 0xdd, 0x0d, 0x79, 0xe3, 0xd8, 0x78, 0x62, 0x38, 0xc1, 0x51,
	0xf8, 0x63, 0x54, 0xe3, 0x7e, 0x7a, 0x8d, 0x5e, 0xcf, 0x27, 0x57, 0xd9, 0xbd, 0xf7, 0x1b, 0x38,
	0x70, 0xe9, 0x09, 0xa4, 0x43, 0x40, 0x92, 0x5c, 0x37, 0x9a, 0x4a, 0xbd, 0x50, 0x13, 0x57, 0xc8,
	0xce, 0xea, 0x72, 0x43, 0xae, 0x1f, 0xd5, 0x45, 0x81, 0x0e, 0x0a, 0x2f, 0xe9, 0x20, 0x96, 0xfb,
	0x91, 0x00, 0xc9, 0x9a, 0xd5, 0x63, 0xc6, 0x17, 0xba, 0x52, 0x61, 0xea, 0x4a, 0x11, 0xc4, 0x47,
	0x9a, 0x7b, 0xe2, 0x6d, 0x8c, 0x7c, 0x23, 0x19, 0x12, 0xde, 0xed, 0xb1, 0xc7, 0xd9, 0xee, 0xd2,
	0x11, 0x82, 0x5f, 0xa0, 0x47, 0x9f, 0x1b, 0x42, 0x26, 0xec, 0x2f, 0x23, 0x63, 0xa2, 0x0c, 0xc9,
	0x01, 0x97, 0x93, 0x57, 0x69, 0x1e, 0x2f, 0x75, 0x5e, 0xde, 0xe6, 0x14, 0x9f, 0x5c, 0xfa, 0x3f,
	0x01, 0x76, 0xa2, 0x0a, 0xf5, 0xd3, 0x85, 0x3b, 0x61, 0xa6, 0x70, 0x87, 0x5e, 0x41, 0x86, 0x76,
	0x42, 0x98, 0x2e, 0x4b, 0xcb, 0x57, 0xe9, 0xad, 0x3d, 0x5d, 0xfe, 0x8f, 0x80, 0x7c, 0x89, 0x91,
	0xd3, 0x97, 0x52, 0xba, 0x17, 0x0c, 0x88, 0xee, 0x8e, 0xfa, 0x23, 0x95, 0x17, 0x2d, 0xe9, 0x29,
	0x57, 0x57, 0x94, 0xe4, 0xa8, 0x3f, 0x3a, 0xc4, 0xe7, 0xb2, 0x2e, 0x95, 0x69, 0xa9, 0xc7, 0x47,
	0xbf, 0x0d, 0xd9, 0x52, 0xb3, 0xd1, 0xa9, 0x34, 0x3a, 0x6a, 0xe7, 0x55, 0xab, 0x32, 0x93, 0xfb,
	0xdc, 0x84, 0x6b, 0x6d, 0xb9, 0xde, 0xaa, 0x55, 0xd4, 0xb6, 0x7c, 0xd0, 0x90, 0x1b, 0x07, 0xea,
	0xf7, 0xda, 0xcd, 0x86, 0x28, 0x14, 0x93, 0x5e, 0x59, 0x54, 0xfa, 0xf1, 0x1a, 0xac, 0xb3, 0x7a,
	0x2e, 0x6a, 0xc1, 0xa6, 0xe3, 0x5a, 0x36, 0xfd, 0x1b, 0x97, 0x42, 0xf8, 0x8b, 0xf3, 0xde, 0x9c,
	0x2a, 0x30, 0xc3, 0x65, 0xc4, 0xc5, 0x58, 0x56, 0xa8, 0xae, 0x28, 0x1b, 0x4e, 0x18, 0x88, 0x0e,
	0x88, 0x93, 0x1f, 0x59, 0x1e, 0xbb, 0x85, 0xbd, 0x09, 0x0a, 0x1e, 0x59, 0x53, 0xbc, 0xc0, 0xf6,
	0x21, 0xe8, 0x37, 0xe1, 0xa6, 0x57, 0xee, 0x57, 0x67, 0x64, 0x8c, 0x2f, 0x2d, 0xa3, 0x72, 0xdd,
	0xe3, 0x31, 0x05, 0x46, 0x2f, 0x60, 0x73, 0xba, 0xbd, 0x85, 0x5a, 0x61, 0x7a, 0xff, 0x03, 0x2f,
	0x5c, 0x78, 0xfd, 0x30, 0x79, 0x86, 0x96, 0x9f, 0xec, 0xe5, 0x2b, 0x67, 0x2e, 0x36, 0x75, 0xac,
	0x33, 0x16, 0x25, 0x46, 0xa7, 0x6c, 0x38, 0xe1, 0x21, 0x32, 0x21, 0xa7, 0xe9, 0xba, 0x41, 0x2e,
	0x5c, 0x1b, 0xa8, 0xd3, 0x6b, 0x38, 0xb4, 0xa8, 0xf9, 0x3a, 0x8b, 0x64, 0x03, 0x9e, 0x53, 0x13,
	0x0e, 0xaa, 0x43, 0xda, 0x7f, 0xe2, 0x63, 0xef, 0x6f, 0x91, 0x6f, 0x2f, 0xaa, 0xe1, 0xe7, 0x83,
	0x02, 0x01, 0x2b, 0x5b, 0xc2, 0xb1, 0x0f, 0xc8, 0xa9, 0xb0, 0x35, 0x33, 0x1d, 0x51, 0x59, 0x7c,
	0x1a, 0x7e, 0xe0, 0xcf, 0xbd, 0xdc, 0x80, 0x4f, 0xa8, 0xf6, 0x48, 0xb4, 0x90, 0x6d, 0x56, 0xfa,
	0x85, 0x40, 0x52, 0x7f, 0xff, 0xba, 0xa7, 0xff, 0xd2, 0x10, 0x66, 0xff, 0xd2, 0xb8, 0x05, 0x29,
	0xaa, 0x56, 0x21, 0x0f, 0x9b, 0x24, 0x80, 0x06, 0xcb, 0x98, 0xd3, 0x5d, 0x5b, 0x33, 0x7b, 0x27,
	0xa1, 0x84, 0x98, 0x68, 0x13, 0x03, 0x52, 0x94, 0x5b, 0x90, 0x74, 0xb5, 0x3e, 0x9b, 0x8f, 0xf3,
	0xf9, 0x84, 0xab, 0xf5, 0xe9, 0xe4, 0x1d, 0x80, 0x9e, 0x35, 0x1c, 0x1a, 0xae, 0xea, 0x9c, 0x68,
	0x2c, 0x78, 0x90, 0x67, 0x23, 0x83, 0xb5, 0x4f, 0xb4, 0x22, 0x04, 0x6e, 0x5c, 0x52, 0x61, 0x63,
	0x5a, 0x97, 0x6e, 0xc0, 0x3a, 0xff, 0xa3, 0x86, 0xbb, 0x4d, 0x36, 0x22, 0x66, 0xdd, 0xc7, 0xa6,
	0x57, 0xc9, 0x61, 0x32, 0x87, 0x20, 0x84, 0xce, 0xea, 0x92, 0xed, 0x79, 0xc5, 0x3c, 0x36, 0x92,
	0xfe, 0x3b, 0x03, 0xdb, 0x17, 0xdc, 0x26, 0x39, 0x9f, 0xde, 0xc4, 0x71, 0x54, 0xa7, 0x67, 0xf1,
	0x42, 0x7e, 0x4c, 0x49, 0x11, 0x48, 0x9b, 0x00, 0x50, 0x0d, 0x92, 0x0e, 0x9e, 0x60, 0xfa, 0x96,
	0x65, 0xae, 0xe9, 0x83, 0x65, 0x1d, 0x72, 0x9b, 0xd3, 0x29, 0x3e, 0x07, 0xf2, 0xea, 0xf7, 0x52,
	0x72, 0x56, 0x2a, 0xcb, 0x2f, 0xcb, 0x8c, 0xe5, 0xe3, 0x8a, 0x47, 0x9e, 0xfb, 0x97, 0xb7, 0x1e,
	0x36, 0x9b, 0x53, 0x61, 0xf3, 0xf3, 0x2b, 0x86, 0x9d, 0xb7, 0x15, 0x39, 0xff, 0x71, 0x15, 0xd6,
	0xd9, 0x5e, 0xe7, 0xc7, 0xcd, 0x6c, 0x50, 0x3b, 0x61, 0xff, 0xed, 0xf9, 0xb5, 0x10, 0x0d, 0x76,
	0x86, 0x86, 0xa9, 0x6a, 0xc7, 0xc7, 0xb8, 0xe7, 0x62, 0xdd, 0x4f, 0x84, 0xd6, 0x5f, 0x2f, 0x94,
	0xa2, 0xa1, 0x61, 0x16, 0x38, 0x2f, 0xef, 0xb0, 0xc9, 0x12, 0xda, 0xd9, 0xc5, 0x25, 0x12, 0xaf,
	0xbb, 0x84, 0x76, 0x36, 0xbb, 0xc4, 0x3d, 0xd8, 0xf0, 0x34, 0x26, 0x64, 0x58, 0x4a, 0xc6, 0x03,
	0x52, 0xdb, 0x9a, 0xc9, 0x07, 0x53, 0x17, 0xf3, 0x41, 0x1d, 0x36, 0x8f, 0x8d, 0x33, 0xac, 0xab,
	0x7e, 0x84, 0x67, 0xbe, 0xf8, 0x8b, 0xd7, 0x7a, 0x73, 0xfa, 0x11, 0x7f, 0x83, 0x32, 0xf5, 0xb3,
	0x9b, 0x6f, 0x41, 0x86, 0x9f, 0x3e, 0x8b, 0xdf, 0xec, 0x4f, 0xd3, 0x34, 0x87, 0x11, 0x3e, 0xb9,
	0xff, 0x15, 0x60, 0x27, 0xea, 0xfd, 0x4a, 0x54, 0xd4, 0x8f, 0xf9, 0x29, 0x5e, 0xe5, 0x0c, 0x1b,
	0x5c, 0xfc, 0x8d, 0x0d, 0x6e, 0xda, 0xba, 0xd7, 0x66, 0xad, 0xfb, 0x15, 0x6c, 0x78, 0xc2, 0x1b,
	0x8e, 0x33, 0xc6, 0x3c, 0x90, 0x7c, 0xb8, 0xec, 0x8a, 0x3c, 0x2b, 0x92, 0x09, 0xad, 0xe2, 0x9d,
	0x03, 0x1d, 0xe5, 0xfe, 0x20, 0x06, 0x99, 0xf0, 0x34, 0xfa, 0x01, 0x6c, 0xfb, 0x4a, 0xe3, 0xdf,
	0x88, 0xf0, 0x36, 0x6e, 0x44, 0xf4, 0xf8, 0xfa, 0x97, 0x72, 0xf1, 0xea, 0x63, 0xbf, 0x84, 0xab,
	0xbf, 0xa0, 0xa7, 0xab, 0x17, 0xf5, 0x34, 0xf7, 0xa7, 0x02, 0x5c, 0x8f, 0xe4, 0xb6, 0x94, 0x7d,
	0xc7, 0xa6, 0xed, 0x3b, 0x94, 0x1d, 0xc7, 0xdf, 0x2c, 0x3b, 0x96, 0x7e, 0x1b, 0x92, 0x9e, 0xbe,
	0xa0, 0x2c, 0xec, 0xb4, 0x2b, 0xcf, 0x2b, 0x8a, 0xdc, 0x79, 0x35, 0x93, 0xf5, 0x79, 0x8e, 0xaa,
	0x50, 0x63, 0x6f, 0x96, 0x5a, 0xf3, 0x85, 0x18, 0x23, 0xae, 0xac, 0x5e, 0x29, 0xcb, 0x47, 0x75,
	0x71, 0x15, 0x25, 0x21, 0x5e, 0x95, 0x0f, 0xaa, 0x62, 0x1c, 0x65, 0x20, 0x59, 0x52, 0xe4, 0x8e,
	0x5c, 0x2a, 0xd4, 0xc4, 0xb5, 0xfd, 0xbf, 0x16, 0x21, 0x71, 0xc0, 0x64, 0x43, 0x3f, 0x15, 0x60,
	0x63, 0xaa, 0xdf, 0x13, 0xcd, 0x29, 0x24, 0x44, 0xb5, 0x00, 0xe7, 0x2e, 0xed, 0x42, 0x93, 0xf6,
	0x7e, 0xf4, 0xcf, 0xff, 0xfe, 0xb3, 0xd8, 0xfb, 0xe8, 0xbd, 0x5d, 0xbf, 0x55, 0xfa, 0x87, 0xe4,
	0x42, 0xbe, 0xe0, 0x71, 0xde, 0xd9, 0x7d, 0xb4, 0x1b, 0x6a, 0x54, 0xdb, 0x7d, 0xf4, 0x15, 0xfa,
	0x4b, 0x01, 0xb6, 0x66, 0x3a, 0xe6, 0xd0, 0x9c, 0xf4, 0x26, 0xba, 0xd5, 0x38, 0xf7, 0x78, 0x49,
	0x6c, 0xd6, 0x02, 0x17, 0x29, 0x23, 0x6b, 0x0d, 0x0b, 0x49, 0xf9, 0x55, 0x58, 0x4c, 0xf4, 0xc7,
	0x02, 0x88, 0xb3, 0x1d, 0xc6, 0x68, 0xde, 0x9f, 0x55, 0xd1, 0x9d, 0xc8, 0xb9, 0x1b, 0x17, 0xea,
	0x14, 0x95, 0xe1, 0xc8, 0x3d, 0xf7, 0xc4, 0x79, 0x74, 0x85, 0x23, 0xfb, 0x2b, 0x01, 0xc4, 0xd9,
	0x0e, 0xe6, 0x79, 0xe2, 0xcc, 0xe9, 0x74, 0x5e, 0xe2, 0x2e, 0xbf, 0xa0, 0x82, 0x7d, 0x2c, 0x2d,
	0x7f, 0x4e, 0x9f, 0x85, 0xfa, 0x8f, 0xa9, 0x90, 0xb3, 0x1d, 0xcf, 0xf3, 0x84, 0x9c, 0xd3, 0x19,
	0xbd, 0xbc, 0x90, 0xfb, 0xcb, 0x9f, 0xde, 0x94, 0x90, 0x7f, 0x2e, 0xc0, 0xf6, 0x85, 0xfe, 0x67,
	0x94, 0x5f, 0xc2, 0x26, 0x42, 0x6d, 0xbb, 0xb9, 0x05, 0x7d, 0xa1, 0xd2, 0xc7, 0x54, 0xc0, 0x3d,
	0xb4, 0xbb, 0xb4, 0x80, 0xbb, 0xb4, 0x93, 0x14, 0x9d, 0x41, 0x82, 0xf7, 0x6f, 0xa3, 0x77, 0xe7,
	0xca, 0xb3, 0xac, 0x14, 0xef, 0x53, 0x29, 0xee, 0xa3, 0x7b, 0x0b, 0xa4, 0xa0, 0xcb, 0x12, 0xf5,
	0xfa, 0x23, 0x01, 0x52, 0x7e, 0xc7, 0x2c, 0xfa, 0xb5, 0xf9, 0xd6, 0x15, 0x6e, 0x02, 0xcf, 0x3d,
	0xb8, 0x14, 0x8f, 0xdb, 0x5f, 0x94, 0x2c, 0x11, 0x7a, 0xc5, 0x4e, 0xe1, 0x4b, 0x80, 0xa0, 0xb5,
	0x1b, 0x3d, 0x58, 0x64, 0x72, 0xe1, 0xb3, 0x98, 0x67, 0x6c, 0x7c, 0xed, 0x47, 0x4b, 0x9d, 0xc3,
	0xd7, 0x02, 0x40, 0xd0, 0x2d, 0x3e, 0x6f, 0xf1, 0x0b, 0xfd, 0xe4, 0x0b, 0x2f, 0x82, 0x5b, 0xbb,
	0xb4, 0xcc, 0xe6, 0x3f, 0xa3, 0x0d, 0xdd, 0x54, 0x8c, 0xa0, 0x55, 0x7c, 0x9e, 0x18, 0x17, 0x9a,
	0xc9, 0x97, 0x11, 0x63, 0x7f, 0x99, 0x73, 0xe0, 0x62, 0xfc, 0x5c, 0x80, 0x6b, 0x11, 0x0d, 0xdd,
	0xe8, 0x83, 0xc5, 0xf7, 0x1e, 0xe1, 0xaf, 0xf7, 0xae, 0x40, 0xc1, 0x75, 0x66, 0x19, 0x2b, 0xf2,
	0xe4, 0x9d, 0xf2, 0xdc, 0x3f, 0x13, 0x60, 0x6b, 0xa6, 0x3f, 0x78, 0x5e, 0x74, 0x89, 0x6e, 0x23,
	0xce, 0x2d, 0xfe, 0x6b, 0x5e, 0x7a, 0x42, 0x25, 0x7b, 0x2c, 0x3d, 0xbc, 0xc4, 0x4b, 0xfa, 0xdd,
	0xd1, 0x9f, 0x09, 0x8f, 0xa8, 0x54, 0x33, 0x1d, 0xd2, 0xf3, 0xa4, 0x8a, 0x6e, 0xa4, 0x5e, 0x52,
	0xaa, 0xfd, 0x87, 0x8b, 0xbc, 0x8e, 0x2f, 0x12, 0xb9, 0x64, 0xe1, 0x51, 0x31, 0xf5, 0xfd, 0x04,
	0x17, 0xa1, 0xbb, 0x4e, 0xed, 0xe6, 0xc9, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0xaa, 0xf0, 0xe3,
	0x66, 0xf2, 0x34, 0x00, 0x00,
}
